
#+STARTUP: content
#+DESCRIPTION: Minimalistic emacs.
#+PROPERTY: header-args :results silent :tangle-mode (identity #o644) :mkdirp yes
#+PROPERTY: header-args:emacs-lisp :comments link
#+STARTUP: content

#+TITLE: Emacs config for minimalist.

* Lexical binding
Enable lexical binding for tangled file
#+BEGIN_SRC emacs-lisp :comments no
;;; -*- lexical-binding: t; -*-
#+END_SRC

* Links
- [[https://github.com/Artawower/.emacs.d][My previous emacs config.]]

* Installation
#+BEGIN_SRC bash :tangle no
brew install emacs-plus@31 --with-debug --with-xwidgets --with-imagemagick --with-native-comp --with-modern-doom3-icon --with-dbus
#+END_SRC

[[https://www.reddit.com/r/emacs/comments/1cu82z8/comment/l4izeij/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button][Move to applications folder]]
#+BEGIN_SRC emacs-lisp  :tangle no
osascript -e 'tell application "Finder" to make alias file to posix file "/opt/homebrew/opt/emacs-plus@31/Emacs.app" at POSIX file "/Applications" with properties {name:"Emacs.app"}'
#+END_SRC

* Required variables
** Env variables
#+BEGIN_SRC emacs-lisp
(setenv "LSP_USE_PLISTS" "true")
(setenv "TERM" "xterm-256color")
#+END_SRC
** Variables
#+BEGIN_SRC emacs-lisp
(setq my/user-email "artawower33@gmail.com")
#+END_SRC
** Paths
Config path
#+BEGIN_SRC emacs-lisp
(setq my/config-dir "~/.config/")
(setq my/emacs-config-dir (concat my/config-dir "emacs/"))
(setq my/config-file (concat my/emacs-config-dir "README.org"))
#+END_SRC

Function for getting config related paths
#+BEGIN_SRC emacs-lisp
(defun my/get-config-related-path (path)
  "Get PATH relative to the Emacs config directory."
  (concat my/emacs-config-dir path))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq my/org-roam-dir (expand-file-name "~/Yandex.Disk.localized/Dropbox/org-roam"))
(setq my/agenda-dir (concat my/org-roam-dir "/agenda/"))

(setq my/org-roam-charts-dir (expand-file-name "~/Yandex.Disk.localized/Dropbox/org-roam/charts"))
(setq my/config-path (my/get-config-related-path "README.org"))
(setq my/backup-dir (expand-file-name "~/tmp/emacs-backups"))
(setq my/private-config-path (my/get-config-related-path "private.el"))
(setq my/doom-theme-directory (expand-file-name "~/.doom.d/themes"))
(setq my/templates-dir (my/get-config-related-path "templates"))
#+END_SRC
** Patches
#+BEGIN_SRC emacs-lisp
(defvar flymake-allowed-file-name-masks nil)
(setq flymake-err-line-patterns nil)
#+END_SRC
** UI variables
#+BEGIN_SRC emacs-lisp
;; (setq my/font-height 14)
;; (setq my/font-default "Monaspace Neon NF")
;; (setq my/font-default "JetBrainsMono Nerd Font")
;; (setq my/font-funny   "Monaspace Radon NF")
(setq my/font-height 16)
(setq my/font-default "Myna Nerd Font")
(setq my/font-comic   "Myna Nerd Font")
(setq my/ui-box-padding 6)
(setq my/org-tag-color "#ff5555")

(defface my/comic-face
  `((t :inherit 'shadow :family ,my/font-comic :height 1.0 :italic t))
  "Face for funny font."
  :group 'my-faces)

;; (set-face-attribute 'my/comic-face nil :inherit 'shadow :family my/comic-face :height 1.0 :italic t)

;; (set-face-attribute 'my/comic-face nil :inherit 'shadow :family my/font-funny :height 1.0 :italic t)
#+END_SRC

** Linux specific configs
*** Copy
#+BEGIN_SRC emacs-lisp :results silent
(when (string= (getenv "XDG_SESSION_TYPE") "wayland")
  (setq wl-copy-process nil)
  
  (defun wl-copy (text)
    (setq wl-copy-process
          (make-process :name "wl-copy"
                        :buffer nil
                        :command '("wl-copy" "-t" "text/plain")
                        :connection-type 'pipe
                        :noquery t))
    (process-send-string wl-copy-process text)
    (process-send-eof wl-copy-process))

  (defun wl-paste ()
    (if (and wl-copy-process (process-live-p wl-copy-process))
        nil ; Don't paste what we just copied
      (shell-command-to-string "wl-paste -n -t text/plain")))

  (setq interprogram-cut-function 'wl-copy)
  (setq interprogram-paste-function 'wl-paste))
#+END_SRC
* Bootstrap
** Garbage collector
#+BEGIN_SRC emacs-lisp
(let* ((normal-gc-cons-threshold (* 100 1024 1024))
       (init-gc-cons-threshold (* 256 1024 1024)))
  (setq gc-cons-threshold init-gc-cons-threshold)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (* 20 1024 1024)))))
#+END_SRC
** Max process
#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC
** Some performance optimization
*** Package quick start
#+BEGIN_SRC emacs-lisp
(setq package-quickstart t)
#+END_SRC
*** Initial mode
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'fundamental-mode)
#+END_SRC
*** Buffer naming startup
https://github.com/D4lj337/Emacs-performance
#+BEGIN_SRC emacs-lisp
(defvar startup/file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq file-name-handler-alist startup/file-name-handler-alist)
            (makunbound 'startup/file-name-handler-alist)))
#+END_SRC

*** Disable modeline and backups while loading
#+BEGIN_SRC emacs-lisp
(setq
 mode-line-format nil
 make-backup-files nil
 backup-directory-alist '((".*" . "~/.local/share/Trash/files")))
#+END_SRC

*** Set shell
#+BEGIN_SRC emacs-lisp :results silent
(setq shell-file-name (executable-find "dash"))
(setq sh-shell (executable-find "dash"))
(setq sh-shell-file (executable-find "dash"))
#+END_SRC
* Package manager.
** Elpaca. Package manager.
#+BEGIN_SRC emacs-lisp
(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
;; NOTE: Lock file for reproducible package versions
;; (setq elpaca-lock-file "/Users/darkawower/apps/flat-emacs/elpaca.lock")

(setq package-install-upgrade-built-in t)
#+END_SRC

** Use package
#+BEGIN_SRC emacs-lisp
;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable :ensure use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :ensure t unless otherwise specified.
  (setq elpaca-use-package-by-default t)
  (setq use-package-compute-statistics t))

;; Block until current queue processed.
(elpaca-wait)
#+END_SRC
** Melpa
#+BEGIN_SRC emacs-lisp
(require 'package)

(customize-set-variable 'package-archives
                        `(,@package-archives
                          ("melpa" . "http://melpa.org/packages/")
                          ("melpa-mirror" . "http://melpa.milkbox.net/packages/")
                          ("jcs-elpa" . "https://jcs-emacs.github.io/jcs-elpa/packages/")
                          ("melpa-stable" . "http://stable.melpa.org/packages/")
                          ("org" . "https://orgmode.org/elpa/")
                          ))
(customize-set-variable 'package-enable-at-startup nil)
;; NOTE: Package initialization is handled by elpaca
;; (package-initialize)
#+END_SRC

* Dependencies
Transient
#+BEGIN_SRC emacs-lisp :results silent
(use-package transient :ensure t :defer t)
#+END_SRC
* Helpers
** Push multiple values
#+BEGIN_SRC emacs-lisp
(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))
#+END_SRC

** Run once on daemon/frame init
#+BEGIN_SRC emacs-lisp
(defun my/run-once-on-init (fn &optional depth name)
  "Run FN once when Emacs is ready, accounting for daemon mode.
In daemon mode runs on first frame creation, otherwise after init.
Automatically removes itself after execution. DEPTH controls hook priority.
NAME is optional function name for the wrapper."
  (let* ((fn-name (or name
                      (intern (format "my/run-once-init-%d"
                                      (abs (random))))))
         (wrapper-fn
          (lambda ()
            (funcall fn)
            (remove-hook 'server-after-make-frame-hook fn-name)
            (remove-hook 'after-init-hook fn-name))))
    (fset fn-name wrapper-fn)
    (let ((hook (if (daemonp)
                    'server-after-make-frame-hook
                  'after-init-hook))
          (hook-depth (or depth -95)))
      (add-hook hook fn-name hook-depth))))
#+END_SRC

** Display buffer in center childframe
#+BEGIN_SRC emacs-lisp :results silent
(defun my/display-buffer-centered-childframe (buf alist)
  (let* ((parent (selected-frame))
         (pw (frame-pixel-width parent))
         (ph (frame-pixel-height parent))
         (char-width (frame-char-width parent))
         (char-height (frame-char-height parent))
         (margin 50)
         (cw (/ (- pw (* 2 margin)) char-width))
         (ch (/ (- ph (* 2 margin)) char-height))
         (params `((parent-frame . ,parent)
                   (left . ,margin)
                   (top . ,margin)
                   (width . ,cw)
                   (height . ,ch)
                   (minibuffer . nil)
                   (undecorated . t)
                   (skip-taskbar . t)
                   (no-accept-focus . nil)
                   (auto-raise . t)
                   (internal-border-width . 1)
                   (z-group . above))))
    (let ((win (display-buffer-in-child-frame buf `((child-frame-parameters . ,params)))))
      (when (window-live-p win)
        (select-frame-set-input-focus (window-frame win))
        (select-window win))
      win)))

#+END_SRC

** Display buffer temporary full size
#+BEGIN_SRC emacs-lisp :results silent
(defvar my/saved-window-configuration nil)
(defvar my/fullsize-original-buffer nil)

(defun my/restore-window-config ()
  (when my/saved-window-configuration
    (set-window-configuration my/saved-window-configuration)
    (setq my/saved-window-configuration nil
          my/fullsize-original-buffer nil)))

(defun my/on-buffer-killed ()
  (my/restore-window-config))

(defun my/on-buffer-changed (window)
  (when (and my/fullsize-original-buffer
             (not (eq (window-buffer window) my/fullsize-original-buffer)))
    (my/restore-window-config)))

(defun my/display-buffer-full-size (buffer alist)
  (setq my/saved-window-configuration (current-window-configuration)
        my/fullsize-original-buffer buffer)
  (delete-other-windows)
  (let ((win (display-buffer-same-window buffer nil)))
    (with-current-buffer buffer
      (add-hook 'kill-buffer-hook #'my/on-buffer-killed nil t)
      (add-hook 'window-buffer-change-functions #'my/on-buffer-changed nil t)
      (local-set-key (kbd "<escape>") #'my/restore-window-config)
      (local-set-key (kbd "q") #'my/restore-window-config))
    win))

#+END_SRC
** Smart display buffer on the right
#+BEGIN_SRC emacs-lisp
(defun my/display-buffer-right-smart (buffer alist)
  "Smart display function that keeps BUFFER on the right side.
Key features:
- Buffer always ends up in the right window
- Maintains maximum 2 windows layout
- Context-aware: respects current window position
- If in right window with 2 windows: moves current buffer to left, BUFFER takes right
- If in left window with 2 windows: BUFFER opens in right
- If only 1 window: splits horizontally, BUFFER opens in right
- Replaces buffers with similar pattern (e.g., <eca 1.*> -> <eca 2.*>)

This function is designed for buffers that should have a consistent
right-side position (e.g., assistants, help, documentation)."
  (let* ((buffer-window (get-buffer-window buffer))
         (buffer-name (buffer-name buffer))
         (pattern-match (when (string-match "^<\\([^>0-9]+\\)" buffer-name)
                          (match-string 1 buffer-name))))
    (cond
     ;; If buffer is already visible, just switch to it
     (buffer-window
      (select-window buffer-window)
      buffer-window)

     ;; If we have exactly 2 windows
     ((= (length (window-list)) 2)
      (let* ((left-window (window-at 0 0))
             (right-window (next-window left-window 'no-minibuf))
             (current-window (selected-window))
             (current-is-right (eq current-window right-window))
             (right-buffer (window-buffer right-window))
             (right-buffer-name (buffer-name right-buffer))
             (should-replace (and pattern-match
                                  (string-match (concat "^<" (regexp-quote pattern-match)) right-buffer-name))))

        (cond
         ;; If right window has similar pattern buffer, replace it
         (should-replace
          (set-window-buffer right-window buffer)
          (select-window right-window)
          right-window)

         ;; If we're in the right window, move its content to left
         (current-is-right
          (let ((current-buffer (window-buffer current-window)))
            (set-window-buffer left-window current-buffer)
            (set-window-buffer right-window buffer)
            (select-window right-window)
            right-window))

         ;; If we're in the left window, just display BUFFER in right
         (t
          (set-window-buffer right-window buffer)
          (select-window right-window)
          right-window))))

     ;; If only one window exists, split horizontally (create window on the right)
     (t
      (let* ((width (or (alist-get 'window-width alist) 0.5))
             (size (if (floatp width)
                       (round (* (frame-width) width))
                     width))
             (new-window (split-window-right (- size))))
        (set-window-buffer new-window buffer)
        (select-window new-window)
        new-window)))))
#+END_SRC

** Porject relative path
#+BEGIN_SRC emacs-lisp :results silent
(defun my/project-relative-path (&optional file)
  (let* ((f (or file buffer-file-name))
         (pr (and f (project-current nil)))
         (root (and pr (project-root pr))))
    (cond
     ((and f root) (file-relative-name f root))
     (f (abbreviate-file-name f))
     (t (buffer-name)))))
#+END_SRC
** Casual package
#+BEGIN_SRC emacs-lisp :results silent
(use-package casual
  :defer t
  :bind (:map org-agenda-mode-map
              ("s-/" . casual-agenda-tmenu))
  :config
  (casual-mode 1))
#+END_SRC
* COMMENT Profiling
** Init debug time
#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :ensure t
  :config
  ;; To disable collection of benchmark data after init is done.
  (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+END_SRC

** Cpu Profiler
#+BEGIN_SRC emacs-lisp
(use-package explain-pause-mode
  :ensure (explain-pause-mode :type git :host github :repo "lastquestion/explain-pause-mode")
  :defer t)
#+END_SRC

* Environment
** Env
Exec path replacement https://www.reddit.com/r/emacs/comments/f8xwau/hack_replace_execpathfromshell/
#+BEGIN_SRC emacs-lisp
;;; Code to replace exec-path-from-shell
;; Need to create file in $HOME/.emacs.d/.local/env
;; use this command to create the file  `printenv > ~/.emacs.d/.local/env'
(defconst my/local-dir (concat user-emacs-directory ".local/"))

(defconst my/env-file (concat my/local-dir "env"))

(defun my/load-envvars-file (file &optional noerror)
  "Read and set envvars from FILE.
If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
unreadable. Returns the names of envvars that were changed."
  (if (not (file-readable-p file))
      (unless noerror
        (signal 'file-error (list "Couldn't read envvar file" file)))
    (let (envvars environment)
      (with-temp-buffer
        (save-excursion
          (insert "\n")
          (insert-file-contents file))
        (while (re-search-forward "\n *\\([^#= \n]*\\)=" nil t)
          (push (match-string 1) envvars)
          (push (buffer-substring
                 (match-beginning 1)
                 (1- (or (save-excursion
                           (when (re-search-forward "^\\([^= ]+\\)=" nil t)
                             (line-beginning-position)))
                         (point-max))))
                environment)))
      (when environment
        (setq process-environment
              (append (nreverse environment) process-environment)
              exec-path
              (if (member "PATH" envvars)
                  (append (split-string (getenv "PATH") path-separator t)
                          (list exec-directory))
                exec-path)
              shell-file-name
              (if (member "SHELL" envvars)
                  (or (getenv "SHELL") shell-file-name)
                shell-file-name))
        envvars))))

(when (and (or (display-graphic-p)
               (daemonp))
           (file-exists-p my/env-file))
  (my/load-envvars-file my/env-file))


(defun my/reload-envvars ()
  "Reload envvars from `my/env-file'."
  (interactive)
  (my/load-envvars-file my/env-file t))
#+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
(when my/backup-dir
  (setq backup-directory-alist `(("." . ,my/backup-dir))))
(setq lock-file-name-transforms
      '(("\\`/.*/\\([^/]+\\)\\'" "/var/tmp/\\1" t)))
#+END_SRC
** Warning level
#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :emergency)
(setq warning-suppress-log-types '((comp) (undo discard-info)))
#+END_SRC
** No littering
#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :demand t
  :config
  (when my/backup-dir
    (setq backup-directory-alist `(("." . ,my/backup-dir))))
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
  (setq backup-by-copying t))
#+END_SRC
** Load private configs
#+BEGIN_SRC emacs-lisp
(ignore-errors
  (when my/private-config-path
    (load my/private-config-path)))
#+END_SRC
** Setup external apps
*** Browser
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq browse-url-firefox-program nil)
  (setq browse-url-browser-function 'browse-url-default-macosx-browser))
#+END_SRC


* Productivity
** Wakatime
#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :defer 2
  :config
  (global-wakatime-mode))
#+END_SRC

** Functions
*** Better window spliting
#+BEGIN_SRC emacs-lisp :results silent
(defun my/split-window-h ()
    "Split window horizontally and focus the new window."
    (interactive)
    (let ((new-window (split-window-right)))
        (select-window new-window)))

(defun my/split-window-v ()
    "Split window vertically and focus the new window."
    (interactive)
    (let ((new-window (split-window-below)))
        (select-window new-window)))
#+END_SRC
*** Open youtrack
 #+BEGIN_SRC emacs-lisp
(defvar my/youtrack-url "https://verifika.youtrack.cloud/issue")
(defconst my/youtrack-url-regexp "VW-[[:digit:]]*")

(defun my/open-current-task-youtrack-url ()
  "Open current task in YouTrack"
  (interactive)
  (when-let* ((branch-name (magit-get-current-branch))
              (matched-res (string-match my/youtrack-url-regexp branch-name))
              (task-name (substring branch-name (match-beginning 0) (match-end 0))))

    (browse-url (concat my/youtrack-url "/" task-name))))
 #+END_SRC

*** Try package from github
#+BEGIN_SRC emacs-lisp :results silent
(defun my/try-package-from-github (repo)
  "Try package from github REPO.
REPO should be in format 'owner/repo-name'."
  (interactive "sGitHub repo (owner/name): ")
  (let* ((repo-name (car (last (split-string repo "/"))))
         (package-sym (intern repo-name)))
    (elpaca-try `(,package-sym :host github :repo ,repo))))
#+END_SRC
* UI
** Faces
*** Color getters functions
#+BEGIN_SRC emacs-lisp :results silent
(defun my/get-variable-name-color ()
  "Get color for variable name face from catppuccin theme."
  (if (fboundp 'catppuccin-get-color)
      (catppuccin-get-color 'flamingo)
    (face-attribute 'mode-line :background nil 'font-lock-variable-name-face)))
#+END_SRC

Get safe background
#+BEGIN_SRC emacs-lisp :results silent
(defun my/get-safe-background (face &optional fallback-face)
  "Helper to safely get background color. Returns string or nil, never 'unspecified."
  (let* ((check-face (or fallback-face 'default))
         (color (face-attribute face :background nil t)))
    (if (and (stringp color) (not (string= color "unspecified")))
        color
      (face-attribute check-face :background nil t))))
#+END_SRC

Modeline background colors
#+BEGIN_SRC emacs-lisp :results silent
(defun my/get-modeline-background-color ()
  "Get modeline active background color with safe fallback."
  (let ((region-bg (face-background 'region nil t))
        (modeline-bg (face-attribute 'mode-line :background nil t)))
    (cond
     ((stringp region-bg) region-bg)
     ((stringp modeline-bg) modeline-bg)
     (t "#555555"))))
#+END_SRC

Modeline inactive color
#+BEGIN_SRC emacs-lisp :results silent
(defun my/get-modeline-inactive-color ()
  "Get modeline inactive background color with safe fallback."
  (let ((default-bg (face-background 'default nil t))
        (inactive-bg (face-attribute 'mode-line-inactive :background nil t)))
    (cond
     ((and (stringp default-bg) (fboundp 'color-darken-name))
      (color-darken-name default-bg 5))
     ((stringp inactive-bg) inactive-bg)
     (t "#333333"))))
#+END_SRC

*** Function to apply frame fonts
#+BEGIN_SRC emacs-lisp
(defun my/setup-fonts-to-frame (&optional frame)
  "Apply font settings to FRAME (or selected frame if called interactively)."
  (interactive)
  (let ((frame (or frame (selected-frame))))
    (with-selected-frame frame
      (when (display-graphic-p frame)
        (set-frame-font (format "%s-%d" my/font-default my/font-height) nil t)
        (set-face-attribute 'default frame :family my/font-default :height (* 10 my/font-height))
        (set-face-attribute 'fixed-pitch frame :family my/font-default :height 1.0)
        (set-face-attribute 'variable-pitch frame :family my/font-default :height 1.07)
        (set-face-attribute 'font-lock-string-face  frame :inherit 'my/comic-face)
        (set-face-attribute 'font-lock-comment-face frame :inherit 'my/comic-face)
        (set-face-attribute 'font-lock-keyword-face frame :inherit 'my/comic-face)

        (setq line-spacing 0.3)
        (when (fboundp 'set-fontset-font)
          (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))))

(set-face-attribute 'font-lock-string-face  nil :inherit nil :family 'unspecified :font 'unspecified)
(set-face-attribute 'font-lock-comment-face nil :inherit nil :family 'unspecified :font 'unspecified)
(set-face-attribute 'font-lock-keyword-face nil :inherit nil :family 'unspecified :font 'unspecified)

))

#+END_SRC

*** Mode line and header line faces
#+BEGIN_SRC emacs-lisp
(defun my/setup-modeline--apply ()
  "Internal function to apply modeline settings."
  (let* ((bg-inactive (my/get-modeline-inactive-color))
         (bg (my/get-modeline-background-color)))
    (set-face-attribute 'mode-line nil
                        :background bg
                        :box (list :line-width my/ui-box-padding :color bg))
    (when (facep 'mode-line-active)
      (set-face-attribute 'mode-line-active nil
                          :background bg
                          :box (list :line-width my/ui-box-padding :color bg)))
    (set-face-attribute 'mode-line-inactive nil
                        :background bg-inactive
                        :box (list :line-width my/ui-box-padding :color bg-inactive))
    (when (facep 'header-line)
      (set-face-attribute 'header-line nil
                          :background bg
                          :box (list :line-width my/ui-box-padding :color bg)))
    (when (facep 'header-line-inactive)
      (set-face-attribute 'header-line-inactive nil
                          :background bg-inactive
                          :box (list :line-width my/ui-box-padding :color bg-inactive)))))

(defun my/setup-modeline (&optional _frame &rest _)
  "Configure the modeline and header-line globally."
  (interactive)
  (if (daemonp)
      (run-at-time 0.1 nil #'my/setup-modeline--apply)
    (my/setup-modeline--apply)))
#+END_SRC

*** Divider face setup
#+BEGIN_SRC emacs-lisp :results silent
(defun my/setup-divider (&optional frame)
  "Set up window-divider colors for FRAME (or the current one)."
  (let* ((fr (or frame (selected-frame)))
         (edge (face-attribute 'mode-line-inactive :background fr 'default)))
    (with-selected-frame fr
      (when (fboundp 'window-divider-mode)
        (window-divider-mode 1)
        (customize-set-variable 'window-divider-default-right-width 1)
        (customize-set-variable 'window-divider-default-bottom-width 1))
      (when (facep 'window-divider)
        (set-face-attribute 'window-divider fr :foreground edge))
      (when (facep 'window-divider-first-pixel)
        (set-face-attribute 'window-divider-first-pixel fr :foreground edge))
      (when (facep 'window-divider-last-pixel)
        (set-face-attribute 'window-divider-last-pixel fr :foreground edge)))))
#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package font-core
  :ensure nil
  :hook
  (after-load-theme . my/setup-divider)
  (after-load-theme . my/setup-modeline)
  (after-make-frame-functions . my/setup-divider)
  (after-make-frame-functions . my/setup-fonts-to-frame)
  (server-after-make-frame . my/setup-divider)
  :config
  (unless (daemonp)
    (my/setup-fonts-to-frame)
    (my/setup-divider)))
#+END_SRC

*** COMMENT Ligatures
Temporary disabled due to performance issues on macos
#+BEGIN_SRC emacs-lisp
(use-package ligature
  :hook (after-init . global-ligature-mode)
  :config
  (ligature-set-ligatures '(prog-mode
                            org-mode
                            lsp
                            cc-mode
                            haskell-mode
                            emacs-lisp-mode)
                          '("->" "<-" "-->" "<--" "<-->"
                            "|>" "<|" "=>" "==>" "::" "<=" ">="
                            "~@" "&&"
                            "||=" "!=" "!==" "||" "?=" ":=" "==="
                            "/**" "/*" "*/"
                            "..." ".." ";;" "--" "++" "::"
                            "##" "###" "###")))
#+END_SRC

** Macos title bar
#+BEGIN_SRC emacs-lisp
(use-package ns-auto-titlebar
  :if (eq system-type 'darwin)
  :config
  (ns-auto-titlebar-mode))
#+END_SRC
** Theme
*** Safe themes
#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC
*** Hook for theme loading
#+BEGIN_SRC emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")

(advice-add 'load-theme :after
            (lambda (&rest _)
              (run-hooks 'after-load-theme-hook)))
#+END_SRC
*** COMMENT Doom themes
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :defer t
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (load-theme 'doom-tokyo-night t)
  (doom-themes-visual-bell-config)
  (setq custom-theme-directory my/doom-theme-directory)
  (doom-themes-org-config))
#+END_SRC
*** Ef themes
#+BEGIN_SRC emacs-lisp :results silent
(use-package ef-themes
  :ensure t
  :init
  ;; This makes the Modus commands listed below consider only the Ef
  ;; themes.  For an alternative that includes Modus and all
  ;; derivative themes (like Ef), enable the
  ;; `modus-themes-include-derivatives-mode' instead.  The manual of
  ;; the Ef themes has a section that explains all the possibilities:
  ;;
  ;; - Evaluate `(info "(ef-themes) Working with other Modus themes or taking over Modus")'
  ;; - Visit <https://protesilaos.com/emacs/ef-themes#h:6585235a-5219-4f78-9dd5-6a64d87d1b6e>
  (ef-themes-take-over-modus-themes-mode 1)
  :config
  ;; All customisations here.
  (setq modus-themes-mixed-fonts nil)
  (setq modus-themes-italic-constructs t)


  (defun my/fix-modus-fringes ()
    "Make sure fringes are the same as the background."
    (modus-themes-with-colors
      (custom-set-faces
       `(git-gutter-fr:added ((t :foreground ,green-intense :background nil)))

       `(git-gutter-fr:modified ((t :foreground ,yellow-intense :background nil)))

       `(git-gutter-fr:deleted ((t :foreground ,red-intense :background nil))))))

  (add-hook 'after-load-theme-hook #'my/fix-modus-fringes)

  (modus-themes-load-theme 'ef-duo-dark))
#+END_SRC
*** Modern themes
#+BEGIN_SRC emacs-lisp :results silent
(use-package modern-themes
  :ensure (modern-themes :host github :repo "artawower/modern-themes")
  :config
  (load-theme 'modern-catppuccin-frappe t))
#+END_SRC
*** COMMENT Catppuccin theme
#+BEGIN_SRC emacs-lisp
(use-package catppuccin-theme
  :config
  (setq catppuccin-flavor 'latte)
  ;; (load-theme 'catppuccin t)
  (my/set-catppuccin-theme)
  ;; https://github.com/catppuccin/emacs/issues/55
  (add-hook 'yaml-mode-hook
            (lambda ()
              (face-remap-add-relative 'font-lock-variable-name-face
                                       (list :foreground (catppuccin-get-color 'blue))))))
#+END_SRC
**** Dynamic catppuccin flavor
#+BEGIN_SRC emacs-lisp
(defun my/set-catppuccin-theme ()
  "Set Catppuccin theme based on dark mode state."
  (interactive)
  (when (boundp 'auto-dark--last-dark-mode-state)
    (setq catppuccin-flavor
          (if (eq auto-dark--last-dark-mode-state 'dark)
              'frappe
            'latte))
    (when (functionp 'catppuccin-reload)
      (catppuccin-reload)))
  (run-hooks 'after-load-theme-hook))
#+END_SRC

*** Auto dark mode
#+BEGIN_SRC emacs-lisp
(use-package auto-dark
  ;; :init
  ;; (auto-dark-mode)
  ;; :hook
  ;; (after-make-frame-functions . #'my/server-auto-dark)
  ;; (auto-dark-dark-mode . my/set-catppuccin-theme)
  ;; (auto-dark-light-mode . my/set-catppuccin-theme)
  :config
  (setq auto-dark-allow-osascript nil)
  (setq auto-dark-polling-interval-seconds 5)
  (setq auto-dark-themes
   '((modern-catppuccin-frappe)
     (modern-nano-light)))
  ;; (my/set-catppuccin-theme)
  (setq auto-dark-allow-osascript t)
  (add-hook 'after-make-frame-functions #'my/server-auto-dark))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun my/server-auto-dark (frame)
  (with-selected-frame frame
    (when (display-graphic-p)
      (auto-dark-mode 1)
      ;; Remove hook so it only runs once
      (remove-hook 'after-make-frame-functions #'my/server-auto-dark)
      (my/setup-modeline))))
#+END_SRC
** Fringes via spacious padding
#+BEGIN_SRC emacs-lisp
(use-package spacious-padding
  :hook
  (emacs-startup . spacious-padding-mode)
  :custom
  (spacious-padding-widths '( :internal-border-width 16
                              :header-line-width 8
                              :mode-line-width 0
                              :fringe-width 20
                              :tab-width 4
                              :scroll-bar-width 0))
  (spacious-padding-subtle-mode-line nil)
  :config
  (advice-add 'spacious-padding-set-faces :after #'my/setup-modeline))
#+END_SRC

** Olivetti mode
*** Function for dynamic body width
#+BEGIN_SRC emacs-lisp :results silent
(defun my/count-visible-windows ()
  (length (window-list nil 'no-minibuf)))

(defun my/adjust-olivetti-body-width ()
  (when (bound-and-true-p olivetti-mode)
    (let ((inhibit-message t)
          (message-log-max nil))
      (olivetti-set-width
       (if (> (my/count-visible-windows) 1)
           80
         120)))))
#+END_SRC
*** Core olivetty package
#+BEGIN_SRC emacs-lisp :results silent
(use-package olivetti
  :defer t
  :hook ((markdown-mode org-mode text-mode prog-mode) . olivetti-mode)
  :custom (olivetti-minimum-body-width 80)
  :config (add-hook 'window-configuration-change-hook
                    #'my/adjust-olivetti-body-width))
#+END_SRC
** Auto zoom windows
#+BEGIN_SRC emacs-lisp
(use-package zoom
  :defer t
  :bind (("C-c z m" . zoom-mode))
  :custom
  (zoom-size '(0.618 . 0.618))
  ;; (zoom-ignored-buffer-name-regexps '("^\\*calc" "^\\*vterm" "^\\*combobulate-query-builder" "^\\*dape" "^\\*claude" "^\\*Ediff" "<eca-chat"))
  ;; (zoom-ignored-major-modes '(dired-mode markdown-mode vterm-mode claude-code-prompt-mode ediff-mode eca-mode eca-chat-mode))
  (zoom-ignore-predicates '((lambda () (window-parameter nil 'window-side))))
  :config
  (defun my/fix-ediff-size ()
    (let* ((buf (or (and (boundp 'ediff-control-buffer) ediff-control-buffer)
                    (car (seq-filter
                          (lambda (b)
                            (string-match-p "^\\*Ediff Control Panel" (buffer-name b)))
                          (buffer-list)))))
           (win (and buf (get-buffer-window buf t))))
      (when (window-live-p win)
        (with-selected-window win
          (setq window-size-fixed t)
          (window-resize (selected-window)
                         (- 5 (window-total-height))
                         nil t)))))

  (add-hook 'ediff-after-setup-windows-hook 'my/fix-ediff-size))
#+END_SRC
** Tab bar (echo area)
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package tab-bar-echo-area
  :hook
  (emacs-startup . tab-bar-echo-area-mode)
  :bind (("C-c TAB TAB" . tab-bar-echo-area-display-tab-names))
  :config
  (tab-bar-mode)
  (setq tab-bar-echo-area-display-tab-names-format-string "%s"))
#+END_SRC

*** Tab bar manager
#+BEGIN_SRC emacs-lisp
(use-package tab-bar-lost-commands :defer t)
#+END_SRC

** COMMENT Quick show current file name whens witch
*** Function
TODO: move to package
#+BEGIN_SRC emacs-lisp :results silent
(defcustom my/display-buffer-name-exclude-regexps '("^\\*" "^ \\*Minibuf" "<eca.*")
  "List of regexps for buffer names to exclude from display."
  :type '(repeat string)
  :group 'convenience)

(defun my/display-buffer-name ()
  "Quick display current buffer name."
  (interactive)
  (let* ((buffer-name (buffer-name)))
    (unless (seq-some (lambda (regexp)
                        (string-match-p regexp buffer-name))
                      my/display-buffer-name-exclude-regexps)
      (let* ((win-start (window-start))
         (indent-width (save-excursion
                         (goto-char win-start)
                         (or (get-text-property (point) 'line-prefix)
                             (get-text-property (point) 'wrap-prefix)
                             "")))
         (indent-len (if (stringp indent-width)
                         (string-width indent-width)
                       0))
         (win-width (- (window-body-width) indent-len))
         (text (concat " " buffer-name " "))
         (padding (make-string (max 0 (- win-width (length text))) ?\s))
         (display-text (propertize (concat text padding)
                                   'face 'tab-bar-echo-area-tab
                                   'line-prefix ""
                                   'wrap-prefix ""))
         (line-end (save-excursion
                     (goto-char win-start)
                     (line-end-position)))
         (ov (make-overlay win-start line-end)))
    (overlay-put ov 'display display-text)
    (overlay-put ov 'line-prefix "")
    (overlay-put ov 'wrap-prefix "")
             (overlay-put ov 'priority 1000)
             (run-at-time 1 nil
                          (lambda (overlay)
                            (delete-overlay overlay))
                          ov)))))
#+END_SRC

*** Hooks
#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'window-buffer-change-functions
          (lambda (_) (my/display-buffer-name)))
(add-hook 'window-selection-change-functions
          (lambda (_) (my/display-buffer-name)))
(add-hook 'focus-in-hook #'my/display-buffer-name)
#+END_SRC
** Rotate windows
#+BEGIN_SRC emacs-lisp
(use-package rotate
  :bind (("C-c w R" . rotate-layout)
         ("C-c w r" . rotate-window)))
#+END_SRC

** Folding, outline
#+BEGIN_SRC emacs-lisp
(use-package outline-indent
  :hook
  ((dart-mode
    yaml-mode
    web-mode
    yaml-ts-mode
    python-mode
    html-mode
    scss-mode
    vue-ts-mode
    ng2-html-mode
    emacs-lisp-mode
    json-mode) . outline-indent-minor-mode)
  :commands outline-indent-minor-mode
  :custom
  (outline-indent-ellipsis " â–¼"))
#+END_SRC

** Hide modeline mode
#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line
  :hook
  (conf-mode . hide-mode-line-mode)
  (fundamental-mode . hide-mode-line-mode)
  (compilation-mode . hide-mode-line-mode)
  (magit-mode . hide-mode-line-mode)
  (prog-mode . hide-mode-line-mode)
  (text-mode . hide-mode-line-mode)
  (org-mode . hide-mode-line-mode))
#+END_SRC


** Icons
#+BEGIN_SRC emacs-lisp
(use-package nerd-icons
  :defer t
  :config
  (set-fontset-font t 'unicode (font-spec :family "Symbols Nerd Font Mono") nil 'append))
#+END_SRC

** Better emacs docs. Helpful
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (("C-h k" . helpful-key)
         ("C-h C-k" . helpful-key)
         ("C-h p" . describe-package)
         ("C-h C-p" . describe-package)
         ("C-h v" . helpful-variable)
         ("C-h C-v" . helpful-variable)
         ("C-h f" . helpful-function)
         ("C-h C-f" . helpful-function)
         ("C-h m" . describe-mode)
         ("C-h C-m" . describe-mode)
         ("C-h ." . helpful-at-point)
         ("C-h F" . describe-face))
  :config
  (add-to-list
   'display-buffer-alist
   '("\\*Help\\*"
     (my/smart-display-buffer-function)))
  (add-to-list
   'display-buffer-alist
   '("\\*helpful"
     (my/smart-display-buffer-function))))
#+END_SRC

** Alias for yes/no
#+BEGIN_SRC emacs-lisp
(ignore-errors
  (setq confirm-kill-emacs 'y-or-n-p)
  (defalias 'yes-or-no-p 'y-or-n-p))
#+END_SRC

** Disable menu bar mode and other stuff
#+BEGIN_SRC emacs-lisp
(set-frame-parameter nil 'alpha-background 1.0)
(add-to-list 'frameset-filter-alist '(ns-transparent-titlebar . t))
(add-to-list 'frameset-filter-alist '(ns-appearance . dark))
(tool-bar-mode -1)
(menu-bar-mode -1)
(setq ring-bell-function 'ignore)
(setq scroll-step 1)
(setq scroll-margin 1)
#+END_SRC
Disable window divider
#+BEGIN_SRC emacs-lisp
(setq window-divider-default-places t
      window-divider-default-bottom-width 1
      window-divider-default-right-width 0)
(window-divider-mode +1)
#+END_SRC

Disable scrolls
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
#+END_SRC

** Truncate lines
#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
#+END_SRC

** Disable default splash screen
#+BEGIN_SRC emacs-lisp
(setq
 inhibit-splash-screen t
 inhibit-startup-screen t
 inhibit-startup-message t
 inhibit-startup-buffer-menu t
 initial-buffer-choice nil
 initial-scratch-message nil)
#+END_SRC


** Full size from startup
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
;; Disable title bar for macos
;; (add-to-list 'default-frame-alist '(undecorated . t))
#+END_SRC

** Reset themes before apply
#+BEGIN_SRC emacs-lisp
(advice-add 'load-theme :before
            (lambda (&rest _)
              (mapc #'disable-theme custom-enabled-themes)))
#+END_SRC

** COMMENT No distraction package
#+BEGIN_SRC emacs-lisp
(use-package no-distraction
  :hook ((typescript-ts-mode html-ts-mode go-ts-mode vue-ts-mode) . no-distraction-mode)
  :ensure (no-distraction :host github :repo "artawower/no-distraction.el"))
#+END_SRC
** No resize when completion
#+BEGIN_SRC emacs-lisp
(use-package stillness-mode
  :defer 2
  :ensure (:host github :repo "neeasade/stillness-mode.el" :branch "main"))
#+END_SRC

** Show paren mode
#+BEGIN_SRC emacs-lisp
(use-package paren
  :ensure nil
  :hook
  (prog-mode . show-paren-mode)
  (org-mode . show-paren-mode))
#+END_SRC
** Paren face
#+BEGIN_SRC emacs-lisp
(use-package paren-face
  :defer t
  :hook (prog-mode . paren-face-mode)
  :config
  (setq paren-face-regexp (rx (any ?\( ?\) ?\[ ?\] ?\{ ?\}))))
#+END_SRC

** Buffer positioning
#+BEGIN_SRC emacs-lisp
;; Backward compatibility alias
(defalias 'my/smart-display-buffer-function #'my/display-buffer-right-smart
  "Alias for backward compatibility. Use `my/display-buffer-right-smart' instead.")

#+END_SRC
** Highlight keywords
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure (hl-todo :depth nil)
  :hook
  (prog-mode . hl-todo-mode)
  (test-mode . hl-todo-mode)
  :custom
  (hl-todo-keyword-faces
   '(("TODO"   . "#E5C07B")
     ("FIXME"  . "#E06C75")
     ("DEBUG"  . "#C678DD")
     ("REFACTOR"  . "#C678DD")
     ("GOTCHA" . "#FF4500")
     ("NOTE"   . "#98C379")
     ("QUESTION"   . "#98C379")
     ("STUB"   . "#61AFEF")))
  :config
  (global-hl-todo-mode 1))
#+END_SRC
** Highlight colors. Rainbow extension
#+BEGIN_SRC emacs-lisp
(use-package colorful-mode
  :ensure (:type git :host github :repo "DevelopmentCool2449/colorful-mode")
  :hook ((html-mode css-mode scss-mode emacs-lisp-mode org-mode help-mode helpful-mode) . colorful-mode))
#+END_SRC

** Topsy. Sticky header
*** Topsy html
#+BEGIN_SRC emacs-lisp
(defun my/treesit-html-breadcrumbs ()
  "Return a string of breadcrumbs."
  (let ((node (treesit-node-at (point) 'html))
        result)
    (while node
      (when (string= "element" (treesit-node-type node))
        (push (treesit-node-text (treesit-node-child
                                  (treesit-node-child node 0) 1))
              result))
      (setq node (treesit-node-parent node)))
    (mapconcat #'identity result " > ")))
#+END_SRC
*** Topsy for json
#+BEGIN_SRC emacs-lisp
(defun my/treesit-json-breadcrumbs ()
  "Return a string of breadcrumbs for json."
  (let ((node (treesit-node-parent (treesit-node-at (point) 'json)))
        result
        next-child-type)
    (while node
      (setq next-child-type (treesit-node-type (treesit-node-child node 2)))
      (when (and (string= "pair" (treesit-node-type node))
                 (or (string= "object" next-child-type)
                     (string= "array" next-child-type)))
        (push (treesit-node-text (treesit-node-child (treesit-node-child node 0) 1))
              result))
      (setq node (treesit-node-parent node)))
    (mapconcat #'identity result " > ")))
#+END_SRC

*** Topsy for scss
#+BEGIN_SRC emacs-lisp
(defun my/scss-breadcrumbs ()
  "Return a string of breadcrumbs for SCSS mode, showing only nested class selectors."
  (save-excursion
    (let ((current-point (point))
          (classes '())
          (current-indent nil)
          (in-selector nil)
          (line ""))

      ;; First check if we're inside a selector or a property
      (beginning-of-line)
      (setq line (buffer-substring-no-properties
                  (line-beginning-position)
                  (line-end-position)))

      ;; If the current line has a '{', we're likely in a selector
      (setq in-selector (and (string-match-p "{" line)
                             (not (string-match-p "}" line))))

      ;; If we're in a property (not in a selector), move to parent selector
      (when (not in-selector)
        (while (and (> (point) (point-min))
                    (not (looking-at-p ".*{[ \t]*$")))
          (forward-line -1)))

      ;; Get the current line's indentation
      (setq current-indent (current-indentation))

      ;; Start collecting selectors moving backward
      (while (> (point) (point-min))
        ;; Get the current line
        (setq line (buffer-substring-no-properties
                    (line-beginning-position)
                    (line-end-position)))

        ;; Check if this line is a selector (ends with '{')
        (when (string-match-p ".*{[ \t]*$" line)
          ;; Check if indent is less than or equal to our current tracking indent
          (when (or (null current-indent) (<= (current-indentation) current-indent))
            ;; Update our current tracking indent
            (setq current-indent (current-indentation))

            ;; Extract only class selectors from the line
            (let ((class-selectors '()))
              ;; Match class selectors ('.something')
              (with-temp-buffer
                (insert line)
                (goto-char (point-min))
                (while (re-search-forward "\\.[a-zA-Z0-9_-]+" nil t)
                  (let ((class (match-string 0)))
                    ;; Remove anything after a space, comma, pseudo-class, etc.
                    (when (string-match "^\\.[a-zA-Z0-9_-]+" class)
                      (push (match-string 0 class) class-selectors)))))

              ;; Add to our breadcrumbs
              (when class-selectors
                (push (mapconcat #'identity (reverse class-selectors) ", ") classes)))))

        ;; Move to previous line
        (forward-line -1))

      ;; Combine the breadcrumbs
      (if classes
          (mapconcat #'identity (reverse classes) " > ")
        ""))))

#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package topsy
  :bind ("C-c t m" . topsy-mode)
  :config
  (add-to-list 'topsy-mode-functions '(scss-mode . my/scss-breadcrumbs))
  (add-to-list 'topsy-mode-functions '(html-ts-mode . my/treesit-html-breadcrumbs))
  (add-to-list 'topsy-mode-functions '(json-ts-mode . my/treesit-json-breadcrumbs))

  ;; Custom headr with file name
  (setq topsy-header-line-format
        '(:eval
          (let ((filename (when buffer-file-name
                            (concat " " (file-name-nondirectory buffer-file-name))))
                (breadcrumbs (funcall topsy-fn)))
            (list (propertize " " 'display '((space :align-to 0)))
                  (if (and filename breadcrumbs (not (string-empty-p breadcrumbs)))
                      (format "%s > %s"
                              (propertize filename 'face 'bold)
                              breadcrumbs)
                    (or filename breadcrumbs "")))))))
#+END_SRC
** COMMENT Buffer Borders
#+BEGIN_SRC emacs-lisp :results silent
(use-package buffer-box
  :ensure (:host github :repo "rougier/buffer-box"))
#+END_SRC
* Navigation
** Imenu
#+BEGIN_SRC emacs-lisp
(use-package imenu :defer t :ensure nil)
#+END_SRC
** Meow
*** Custom functions
**** Edit after/before eol
#+BEGIN_SRC emacs-lisp
(defun my/edit-after-eol ()
  "Edit the current line to the end of the line like A in the VIM."
  (interactive)
  (meow-line 1)
  (meow-append))

(defun my/edit-before-bol ()
  "Edit the current line to the beginning of the line like I in the VIM."
  (interactive)
  (meow-join 0)
  (meow-append))
#+END_SRC
**** Yank below
#+BEGIN_SRC emacs-lisp
(defun my/meow-yank-below ()
  "Yank below the current line."
  (interactive)
  (forward-line)
  (meow-yank))
#+END_SRC
**** Meow change till EOL
#+BEGIN_SRC emacs-lisp
(defun my/meow-change-till-eol ()
  "Change till the end of line."
  (interactive)
  (let ((meow-eol-thing 108))
    (meow-end-of-thing meow-eol-thing)
    (meow-change)))
#+END_SRC
**** Meow select till EOL
#+BEGIN_SRC emacs-lisp
(defun my/meow-select-till-eol ()
  "Select till the end of line."
  (interactive)
  (let ((meow-eol-thing 108))
    (meow-end-of-thing meow-eol-thing)))
#+END_SRC
**** Meow back till
#+BEGIN_SRC emacs-lisp
(defun my/meow-backward-till (n ch)
  "Move backward till the first character that is not in the list of characters."
  (interactive "p\ncTill:")
  (meow-till -1 ch))
#+END_SRC

**** KILL Navigation
Move to husky
#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
(defun switch-to-first-matching-buffer (regex)
  (switch-to-buffer (car (cl-remove-if-not (apply-partially #'string-match-p regex)
                                           (mapcar #'buffer-name (buffer-list))))))
#+END_SRC
*** Meow Keybindings
#+BEGIN_SRC emacs-lisp
(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; C-c C-j C-/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use C-c C-`C-0-9 for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("?" . meow-keypad-describe-key))
  (meow-normal-define-key
   '("*" . (lambda () (interactive)
             (call-interactively 'meow-mark-symbol)
             (call-interactively 'meow-search)))
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("s-o" . meow-last-buffer)
   '("ge" . end-of-buffer)
   '("gg" . beginning-of-buffer)
   '("gl" . my/meow-select-till-eol)
   '("gh" . beginning-of-line)
   '("6" . meow-expand-6)
   '("@" . meow-end-or-call-kmacro)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '("$" . my/meow-select-till-eol)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("s-d" . meow-inner-of-thing)
   '("s-D" . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("i" . meow-append)
   '("o" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("F" . meow-find)
   '("f" . avy-goto-word-1)
   '("q" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("a" . meow-insert)
   '("O" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("/" . meow-block)
   '("?" . meow-to-block)
   '("P" . meow-yank)
   '("C" . my/meow-change-till-eol)
   '("p" . my/meow-yank-below)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("{" . my/meow-backward-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("V" . meow-visual-line)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("Q" . meow-pop-selection)
   '("'" . repeat)
   '("=" . indent-for-tab-command)
   '(":" . query-replace-regexp)
   '("A" . my/edit-after-eol)
   '("I" . my/edit-before-bol)
   '("<escape>" . ignore))

  (meow-define-keys 'motion
    '("\\n" . meow-normal-mode)
    '("[" . meow-beginning-of-thing)
    '("]" . meow-end-of-thing)
    '("\\q" . kill-current-buffer))

  (meow-define-keys 'insert
   '("s-o" . meow-last-buffer)
   '("s-p" . xah-paste-from-register-1))


  (meow-define-keys 'normal
    '("\\q" . kill-current-buffer)
    '("T" . meow-till-expand)
    '("N" . my/copy-with-ai-context)
    '("z z" . recenter)
    '("C-<tab>" . indent-rigidly-right)
    '("<backtab>" . indent-rigidly-left)
    '("g c" . comment-or-uncomment-region)))

#+END_SRC

*** Meow thing register for better selection
#+BEGIN_SRC emacs-lisp
(defun my/meow-thing-register ()
  (meow-thing-register 'whitespace '(regexp " \\|\n" " \\|\n") '(regexp " \\|\n" " \\|\n"))
  (add-to-list 'meow-char-thing-table '(?w . whitespace))

  (meow-thing-register 'non-whitespace
                         '(syntax . "-")
                         '(syntax . "-"))
  (add-to-list 'meow-char-thing-table '(?e . non-whitespace))

  (add-to-list 'meow-char-thing-table '(?\" . quoted))
  (add-to-list 'meow-char-thing-table '(?' . quoted))
  (add-to-list 'meow-char-thing-table '(?< . angle))

  (add-to-list 'meow-char-thing-table '(?\( . round))
  (add-to-list 'meow-char-thing-table '(?\) . round))

  (add-to-list 'meow-char-thing-table '(?{ . curly))
  (add-to-list 'meow-char-thing-table '(?} . curly))

  (add-to-list 'meow-char-thing-table '(?\[ . square))
  (add-to-list 'meow-char-thing-table '(?\] . square))

  (meow-thing-register 'quoted
                       '(regexp "\"\\|'\\|`" "\"\\|'\\|`")
                       '(regexp "\"\\|'\\|`" "\"\\|'\\|`"))

  (meow-thing-register 'angle
                       '(regexp "<" ">")
                       '(regexp "<" ">")))

#+END_SRC
*** Meow, custom modes
#+BEGIN_SRC emacs-lisp
(defun my/meow-setup-custom-modes ()
  (setq meow-paren-keymap (make-keymap))
  (my/meow-setup-agenda-mode)
  (meow-define-state paren
    "meow state for interacting with smartparens"
    :lighter " [P]"
    :keymap meow-paren-keymap)

  ;; meow-define-state creates the variable
  (setq meow-cursor-type-paren 'hollow)

  (meow-define-keys 'paren
    '("<escape>" . meow-normal-mode)
    '("l" . sp-forward-sexp)
    '("h" . sp-backward-sexp)
    '("j" . sp-down-sexp)
    '("k" . sp-up-sexp)
    '("n" . sp-forward-slurp-sexp)
    '("b" . sp-forward-barf-sexp)
    '("v" . sp-backward-barf-sexp)
    '("c" . sp-backward-slurp-sexp)
    '("u" . meow-undo)))
#+END_SRC

*** Meow. Mode for agenda
#+BEGIN_SRC emacs-lisp :results silent
(defun my/meow-setup-agenda-mode ()
  (setq meow-agenda-motion-keymap (make-keymap))

  (meow-define-state agenda-motion
    "Org-Agenda motion"
    :lighter "[A]"
    :keymap meow-agenda-motion-keymap)

  (meow-define-keys 'agenda-motion
    '("<escape>" . org-agenda-quit)
    '("q" . org-agenda-quit)
    '("j" . org-agenda-next-line)
    '("k" . org-agenda-previous-line)
    '("h" . org-agenda-earlier)
    '("l" . org-agenda-later)
    '("J" . org-agenda-next-item)
    '("K" . org-agenda-previous-item)
    '("f" . avy-goto-word-1)
    '("g" . org-agenda-redo)
    '("." . org-agenda-goto-today)
    '("t" . org-agenda-todo)
    '("s" . org-agenda-schedule)
    '("d" . org-agenda-deadline)
    '(":" . org-agenda-set-tags)
    '("e" . org-agenda-set-effort)
    '("/" . org-agenda-filter)
    '("\\" . org-agenda-filter-by-tag)
    '("v" . org-agenda-view-mode-dispatch)
    '("G" . org-agenda-toggle-time-grid)
    '("L" . org-agenda-log-mode)
    '("i" . org-agenda-clock-in)
    '("o" . org-agenda-clock-out)
    '("c" . org-agenda-capture)
    '("TAB" . org-agenda-goto)
    '("RET" . org-agenda-switch-to)
    '(" " . meow-keypad))


  (add-to-list 'meow-mode-state-list '(org-agenda-mode . agenda-motion)))
#+END_SRC

*** Meow, pair modes
#+BEGIN_SRC emacs-lisp
(defun my/meow-setup-state-per-modes ()
  (add-to-list 'meow-mode-state-list '(elpaca-info-mode . normal))
  (add-to-list 'meow-mode-state-list '(flymake-diagnostics-buffer-mode . normal))
  (add-to-list 'meow-mode-state-list '(flycheck-error-list-mode . normal))
  (add-to-list 'meow-mode-state-list '(magit-process-mode . normal))
  (add-to-list 'meow-mode-state-list '(compilation-mode . normal))
  (add-to-list 'meow-mode-state-list '(helpful-mode . normal))
  (add-to-list 'meow-mode-state-list '(help-mode . normal))
  (add-to-list 'meow-mode-state-list '(detached-compilation-mode-map . normal))
  (add-to-list 'meow-mode-state-list '(messages-buffer-mode . normal))
  (add-to-list 'meow-mode-state-list '(debug-mode . normal))
  (add-to-list 'meow-mode-state-list '(debugger-mode . normal))
  (add-to-list 'meow-mode-state-list '(grep-mode . normal)))
#+END_SRC

*** Meow, core package
#+BEGIN_SRC emacs-lisp
(use-package meow
  :custom
  (meow-use-clipboard t)
  :config
  (meow-setup)
  (define-key mode-specific-map (kbd "j") nil)
  (my/meow-thing-register)
  (my/meow-setup-custom-modes)
  (my/meow-setup-state-per-modes)
  (advice-add #'meow-change :after
              (lambda (&rest _)
                (when (and (bolp) (eolp))
                  (indent-according-to-mode))))
  (meow-global-mode 1))
#+END_SRC

*** Meow. Treesit integration
#+BEGIN_SRC emacs-lisp
(use-package meow-tree-sitter
  :ensure (:host github :repo "skissue/meow-tree-sitter")
  :after meow
  :config
  (meow-tree-sitter-register-defaults))
#+END_SRC

*** Meow vterm
#+BEGIN_SRC emacs-lisp
(use-package meow-vterm
  :ensure (meow-vterm :type git :host github :repo "accelbread/meow-vterm")
  :init
  (meow-vterm-enable)
  :config
  (setq vterm-keymap-exceptions '("C-c")))
#+END_SRC

** Global keybindings
*** macOS modifiers
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'super)
  (setq mac-option-modifier 'meta)
  (setq mac-control-modifier 'control)
  (setq ns-function-modifier 'hyper))
#+END_SRC

*** Standard editing
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-v") 'yank)
(global-set-key (kbd "s-s") 'save-buffer)
(global-set-key (kbd "s-c") 'meow-save)
(global-set-key (kbd "s-u") 'revert-buffer)
(global-set-key (kbd "s-a") 'mark-whole-buffer)
(global-set-key (kbd "s-z") 'undo)
(global-set-key "\C-u" 'my/backward-kill-line)
#+END_SRC

*** Window management
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-l") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-h") 'shrink-window-horizontally)
(global-set-key (kbd "<C-S-up>") 'shrink-window)
(global-set-key (kbd "C-S-j") 'enlarge-window)
(global-set-key (kbd "<C-S-down>") 'enlarge-window)
(global-set-key (kbd "C-S-k") 'shrink-window)
(global-set-key (kbd "C-c w s") 'my/split-window-v)
(global-set-key (kbd "C-c w v") 'my/split-window-h)
(global-set-key (kbd "s-w") 'delete-window)
#+END_SRC

*** File operations
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c .") 'find-file)
(global-set-key (kbd "C-c f D") 'my/delete-this-file)
(global-set-key (kbd "C-c o F") 'ns-open-file-using-panel)
#+END_SRC

*** Buffer operations
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c o l") 'my/open-messages)
(global-set-key (kbd "C-c o M") 'my/open-clear-messages)
(global-set-key (kbd "s-n") (lambda () (interactive) (switch-to-buffer (generate-new-buffer "Untitled"))))
(global-set-key (kbd "C-c q") 'kill-current-buffer)
#+END_SRC

*** Package manager
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c p m") 'elpaca-manager)
(global-set-key (kbd "C-c p M") 'elpaca-log)
#+END_SRC

*** Theme
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-t") 'load-theme)
#+END_SRC

*** Code annotations
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c t t") 'my/insert-todo-by-current-git-branch)
(global-set-key (kbd "C-c t i") 'my/insert-todo-by-current-git-branch)
(global-set-key (kbd "C-c t d") 'my/insert-debug-by-current-git-branch)
(global-set-key (kbd "C-c t n") 'my/insert-note-by-current-git-branch)
#+END_SRC

*** Narrowing
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c +") 'narrow-to-region)
(global-set-key (kbd "C-c -") 'widen)
#+END_SRC

*** Minibuffer navigation
#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-map (kbd "C-j") 'next-history-element)
(define-key minibuffer-local-map (kbd "C-k") 'previous-history-element)
(define-key read--expression-map (kbd "C-j") 'next-history-element)
(define-key read--expression-map (kbd "C-k") 'previous-history-element)
#+END_SRC

** Reverse im. Same commands accross layouts
*** Functions
**** Override meow keypad parsing
#+BEGIN_SRC emacs-lisp
(defun my/meow--keypad-format-key-1 (key)
  "Return a display format for input KEY."
  (setq key `(,(car key) . ,(concat (mapcar (lambda (c) (reverse-im--translate-char c t)) (cdr key)))))
  (cl-case (car key)
    (meta (format "M-%s" (cdr key)))
    (control (format "C-%s" (meow--keypad-format-upcase (cdr key))))
    (both (format "C-M-%s" (meow--keypad-format-upcase (cdr key))))
    (literal (cdr key))))

#+END_SRC
*** Dependency
#+BEGIN_SRC emacs-lisp
(use-package char-fold
  :ensure nil
  :custom
  (char-fold-symmetric t)
  (search-default-mode #'char-fold-to-regexp))
#+END_SRC
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package reverse-im
  :demand t
  :after char-fold
  :custom
  (reverse-im-char-fold t) ; use lax matching
  (reverse-im-read-char-advice-function #'reverse-im-read-char-include)
  (reverse-im-input-methods '("russian-computer")) ; translate these methods
  :config
  (reverse-im-mode t)
  (advice-add 'meow--keypad-format-key-1 :override #'my/meow--keypad-format-key-1))
#+END_SRC
** Avy, quick jump to words
#+BEGIN_SRC emacs-lisp
(use-package avy
  :defer t
  :bind (("s-r" . (lambda () (interactive) (set-mark-command nil) (call-interactively 'avy-goto-char) (right-char 1)))
         ("C-c d l" . avy-kill-whole-line)
         ("M-l" . avy-goto-line)
         :map meow-normal-state-keymap
         ("f" . avy-goto-word-1)
         ("\\f" . avy-goto-char-timer))
  :custom
  (avy-single-candidate-jump t)
  (avy-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?a ?s ?d ?f ?h ?j ?k ?l ?z ?x ?c ?v ?b ?n ?m)))
#+END_SRC

** Ace window. Fast jump between opened windows and frames
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :defer t
  :bind (("s-." . ace-window))
  :config
  (setq aw-ignored-buffers (delq 'treemacs-mode aw-ignored-buffers)))
#+END_SRC

** Better jump between visited positions
*** Functions
#+BEGIN_SRC emacs-lisp
(defun my/better-jump-preserve-pos-advice (oldfun &rest args)
  "Preserve position when jumping."
  (let ((old-pos (point)))
    (apply oldfun args)
    (when (> (abs (- (line-number-at-pos old-pos) (line-number-at-pos (point))))
             1)
      (better-jumper-set-jump old-pos))))
#+END_SRC

Function for preserve better jump befor buffer changed only for prog mode.

#+BEGIN_SRC emacs-lisp
(defun my/better-jump-save-prog-mode-pos (&rest args)
  "Function for preserve better jump befor buffer changed only for prog mode"
  (when (or (derived-mode-p 'prog-mode)
            (eq major-mode 'html-ts-mode)
            (eq major-mode 'html-mode)
            (eq major-mode 'org-mode))
    (call-interactively #'better-jumper-set-jump)))
#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package better-jumper
  :defer 2
  :bind
  (("C-o" . better-jumper-jump-backward)
   ("C-i" . better-jumper-jump-forward)
   ("C-c 1" . better-jumper-set-jump))
  :custom
  (better-jumper-use-evil-jump-advice nil)
  :config
  (advice-add 'meow-end-of-thing :around #'my/better-jump-preserve-pos-advice)
  (advice-add 'avy-goto-word-1 :around #'my/better-jump-preserve-pos-advice)
  ;; TODO: move to husky package
  (advice-add 'husky-actions-find-definition :before (lambda () (call-interactively #'better-jumper-set-jump)))
  (advice-add 'husky-lsp-find-definition :before (lambda () (call-interactively #'better-jumper-set-jump)))
  (advice-add 'husky-lsp-find-definition :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'find-file :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'end-of-buffer :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'beginning-of-buffer :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'project-find-file :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'consult-buffer :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'husky-navigation-bounce-paren :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'lsp-find-references :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'flycheck-next-error :before #'my/better-jump-save-prog-mode-pos)
  (advice-add 'flycheck-previous-error :before #'my/better-jump-save-prog-mode-pos)
  (better-jumper-mode 1))
#+END_SRC
** Bookmarks
Bookmark for navigation inside file
#+BEGIN_SRC emacs-lisp
(use-package bm
  :defer t
  :custom-face
  (bm-face ((t (:inherit font-lock-warning-face :foreground "#ffb6c1" :background unspecified))))
  :custom
  (bm-in-lifo-order t)
  (bm-highlight-fringe 'bm-highlight-line-and-fringe)
  :bind (("M-s-n" . bm-next)
         ("M-s-p" . bm-previous)
         ("s-b" . bm-toggle)
         ("C-c b L" . bm-show-all)
         ("C-c b l" . bm-show)))
#+END_SRC

** Scroll golden ratio
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio-scroll-screen
  :custom-face
  (golden-ratio-scroll-highlight-line-face ((t (:background "#ffb6c1" :extend t))))
  :custom
  (golden-ratio-scroll-highlight-delay '(0.1 . 0.2))
  :config
  (define-key global-map (kbd "C-v") #'golden-ratio-scroll-screen-up)
  (define-key global-map (kbd "M-v") #'golden-ratio-scroll-screen-down)
  (global-set-key [remap scroll-down-command] 'golden-ratio-scroll-screen-down)
  (global-set-key [remap scroll-up-command] 'golden-ratio-scroll-screen-up))
#+END_SRC

** Ultrascroll, smooth scrolling
#+BEGIN_SRC emacs-lisp
(use-package ultra-scroll
  :hook ((after-init . ultra-scroll-mode))
  :ensure (:host github :repo "jdtsmith/ultra-scroll")
  :init
  (setq scroll-conservatively 101 ; important!
        scroll-margin 0)
  :config
  (ultra-scroll-mode 1))
#+END_SRC

* Editing
** Global configs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
#+END_SRC
** Functions
*** Delete backward
#+BEGIN_SRC emacs-lisp
(defun my/backward-kill-line (&optional arg)
  (interactive "p")
  (let ((beg (line-beginning-position))
        (end (point)))
    (kill-region beg end)
    (when kill-ring
      (setq kill-ring (cdr kill-ring)))
    (setq kill-ring-yank-pointer kill-ring)))
#+END_SRC


*** Copy with AI context
#+BEGIN_SRC emacs-lisp
(defun my/copy-with-ai-context (beg end)
  "Copy selected region with context for AI tools.

The format is:
<project-related-path>, line numbers <from>:<to>
<code>"
  (interactive "r")
  (unless (use-region-p)
    (user-error "No active region"))
  (let* ((rb (min beg end))
         (re (max beg end))
         (from (line-number-at-pos rb))
         (to (line-number-at-pos
              (if (and (> re rb)
                       (eq (char-before re) ?\n))
                  (1- re)
                re)))
         (code (buffer-substring-no-properties rb re))
         ;; Determine language from file extension or major mode
         (ext  (and buffer-file-name (downcase (or (file-name-extension buffer-file-name) ""))))
         (mode (downcase (replace-regexp-in-string "-mode\\'" "" (symbol-name major-mode))))
         ;; Get project-related path using file-info--get-project-related-path if available
         (path (if (fboundp 'file-info--get-project-related-path)
                   (or (file-info--get-project-related-path)
                       (or buffer-file-name (buffer-name)))
                 (or buffer-file-name (buffer-name))))
         ;; Format the final string
         (payload (format "%s, line numbers %d:%d\n\n%s\n"
                          path from to code)))
    ;; Copy to kill-ring (and clipboard if enabled)
    (kill-new payload)
    (message "Copied %d chars: %s, lines %d:%d"
             (length payload) path from to)))

#+END_SRC

** Autorevert mode
#+BEGIN_SRC emacs-lisp
(use-package autorevert
    :ensure nil
    :hook ((emacs-startup . global-auto-revert-mode))
    :custom
    (auto-revert-verbose nil)
    (auto-revert-use-notify nil))
#+END_SRC
** Persistent values
#+BEGIN_SRC emacs-lisp
(use-package persistent-values
  :defer t
  :bind (("s-S" . persistent-values-add)
         ("s-I" . persistent-values-search))
  :ensure (persistent-values :host github :repo "artawower/persistent-values.el")
  :config
  (persistent-values-mode 1))
#+END_SRC
** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (("s-x" . er/expand-region))
  :defer t)
#+END_SRC
** Narrowing
#+BEGIN_SRC emacs-lisp
(use-package narrow-indirect
  :ensure (:host github :repo "emacsmirror/narrow-indirect")
  :bind (("C-c 0" . ni-narrow-to-region-indirect-other-window))
  :defer t)
#+END_SRC
** Undo redo
*** Undo mode
#+BEGIN_SRC emacs-lisp
(use-package undo-fu
  :defer t
  :bind (("C-r" . undo-fu-only-redo)
         :map meow-normal-state-keymap
              ("u" . undo-fu-only-undo)))
#+END_SRC
*** Undo sessions (history saving)
#+BEGIN_SRC emacs-lisp
(use-package undo-fu-session
  :after undo-fu
  :config
  (global-undo-fu-session-mode))
#+END_SRC
** Disable sgml-mode bindings
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'sgml-mode
  (setq html-ts-mode-map (make-sparse-keymap))
  (setq html-mode-map (make-sparse-keymap))
  (setq sgml-mode-map (make-sparse-keymap)))
#+END_SRC
** Autopairs
#+BEGIN_SRC emacs-lisp
(use-package electric
  :ensure nil
  :hook
  ((html-mode . sgml-electric-tag-pair-mode)
   (ng2-html-mode . sgml-electric-tag-pair-mode)
   (prog-mode . electric-pair-mode))
  :config
  (when (boundp 'electric-pair-pairs)
    (setq electric-pair-pairs
          (append electric-pair-pairs '((?< . ?>)))))

  (setq electric-pair-preserve-balance nil
        electric-pair-delete-adjacent-pairs t
        electric-pair-skip-whitespace nil
        electric-pair-open-newline-between-pairs t))
#+END_SRC
** Surround 2.0
#+BEGIN_SRC emacs-lisp
(use-package surround
  :ensure t
  :defer t
  :bind-keymap ("M-'" . surround-keymap))
#+END_SRC

** Turbo log. Quick log inserting
#+BEGIN_SRC emacs-lisp
(use-package turbo-log
  :defer t
  :ensure (turbo-log :type git :host github :repo "Artawower/turbo-log.el")
  :commands (turbo-log--get-context)
  :bind (("C-s-l" . turbo-log-print)
         ("C-s-i" . turbo-log-print-immediately)
         ("C-s-h" . turbo-log-comment-all-logs)
         ("C-s-s" . turbo-log-uncomment-all-logs)
         ("C-s-x" . turbo-log-delete-all-logs)
         ("C-s-[" . turbo-log-paste-as-logger)
         ("C-s-]" . turbo-log-paste-as-logger-immediately))
  :custom
  (turbo-log-payload-format-template "%s: ")
  (turbo-log-allow-insert-without-treesit-p t)
  (turbo-log-allow-insert-without-tree-sitter-p t)
  :config
  (turbo-log-configure
   :modes (typescript-ts-mode tsx-ts-mode typescript-mode js2-mode web-mode ng2-ts-mode js-mode)
   :strategy merge
   :post-insert-hooks (apheleia-format-buffer lsp)
   :msg-format-template "'âœŽ: %s'"))
#+END_SRC

** Auto rename tags pairs
#+BEGIN_SRC emacs-lisp
(use-package auto-rename-tag
  :hook ((html-mode . auto-rename-tag-mode)
         (ng2-html-mode . auto-rename-tag-mode)
         (vue-ts-mode . auto-rename-tag-mode)
         (web-mode . auto-rename-tag-mode))
  :defer t)
#+END_SRC

** Macros
#+BEGIN_SRC emacs-lisp
(use-package persistent-soft
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package persistent-kmacro
  :ensure (:host github :repo "artawower/persistent-kmacro.el")
  :defer t
  :bind (("C-c m e" . persistent-kmacro-execute-macro)
         ("C-c m a" . persistent-kmacro-name-last-kbd-macro)
         ("C-c m r" . persistent-kmacro-remove-macro)
         :map meow-normal-state-keymap
         ("#" . persistent-kmacro-apply))
  :config
  (setq persistent-kmacro-macro-file "persistent-kmacro-store.el"))
#+END_SRC

*** Tempel
#+BEGIN_SRC emacs-lisp
(use-package tempel
  :bind
  (("s-y" . tempel-complete)
   ("s-Y" . tempel-insert)
   ("s-\\" . tempel-done))
  :init
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))

  (add-hook 'prog-mode-hook 'tempel-setup-capf)
  (add-hook 'text-mode-hook 'tempel-setup-capf)

  :config
  (setq tempel-auto-reload nil)
  (setq tempel-path
        (directory-files my/templates-dir t "\\`[^.].*\\'")))
#+END_SRC

** Treesitter
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package treesit
  :ensure nil
  :hook
  (go-ts-mode . (lambda () (setq-local tab-width 2)))
  (go-mode . go-ts-mode)
  :mode
  ("\\.js\\'" . js-ts-mode)
  ("\\.yaml\\'" . yaml-ts-mode)
  ("\\.mjs\\'" . typescript-ts-mode)
  ("\\.ts\\'" . typescript-ts-mode)
  ("\\.go\\'" . go-ts-mode)
  ("\\.json\\'" . json-ts-mode)
  ("\\.yaml\\'" . yaml-ts-mode)
  ("\\.lua\\'" . lua-ts-mode)
  ("\\.rs\\'" . rust-ts-mode)
  ("\\.html\\'" . html-ts-mode)
  ("\\.cs\\'" . csharp-ts-mode)
  :custom
  (go-ts-mode-indent-offset 2)
  :config
  (setq treesit-language-source-alist
        '((bash "https://github.com/tree-sitter/tree-sitter-bash")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (just "https://github.com/IndianBoy42/tree-sitter-just")
          (lua "https://github.com/tree-sitter-grammars/tree-sitter-lua")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (vue "https://github.com/ikatyang/tree-sitter-vue")
          (make "https://github.com/alemuller/tree-sitter-make")
          (markdown-inline "https://github.com/ikatyang/tree-sitter-markdown")
          (vue "https://github.com/ikatyang/tree-sitter-vue")
          (markdown "https://github.com/ikatyang/tree-sitter-markdown")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (rust "https://github.com/tree-sitter/tree-sitter-rust")
          (scss "https://github.com/tree-sitter-grammars/tree-sitter-scss")
          (swift "https://github.com/alex-pinkus/tree-sitter-swift")
          (toml "https://github.com/tree-sitter/tree-sitter-toml")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

  (setq treesit-extra-load-path '("~/.emacs.d/tree-sitter"))
  (setq treesit-font-lock-level 3))


#+END_SRC

*** SCSS mode
#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :after flymake
  :custom
  (scss-compile-at-save nil)
  (css-indent-offset 2)
  :hook
  (scss-mode . (lambda ()
                 (setq-local tab-width 2)
                 (setq-local indent-tabs-mode nil))))
#+END_SRC

*** Navigation
#+BEGIN_SRC emacs-lisp
(use-package combobulate
  :after treesit
  :ensure (:host github :repo "mickeynp/combobulate")
  :bind (("s-q" . combobulate-mark-node-dwim)
         ("s-<down>" . combobulate-navigate-logical-next)
         ("s-<up>" . combobulate-navigate-logical-previous)
         ("s-N" . combobulate-navigate-next)
         ("s-P" . combobulate-navigate-previous)
         :map combobulate-key-map
         ("C-M-t" . nil))
  :custom
  (combobulate-key-prefix "C-c c o"))
#+END_SRC

*** Treesitter folding
#+BEGIN_SRC emacs-lisp
(use-package treesit-fold
  :ensure (treesit-fold :type git :host github :repo "abougouffa/treesit-fold")
  :hook ((web-mode
          ng2-html-mode
          ng2-ts-mode
          typescript-mode
          js-mode
          js-ts-mode
          python-ts-mode
          python-mode
          html-mode
          json-mode
          json-ts-mode
          bash-mode
          css-mode
          scss-mode
          go-ts-mode
          typescript-ts-mode) . treesit-fold-mode)
  :config
  (add-to-list 'treesit-fold-range-alist '(ng2-ts-mode . ((export_clause . ts-fold-range-seq)
                                                          (statement_block . treesit-fold-range-seq)
                                                          (comment . treesit-fold-range-c-like-comment))) t)

  (add-to-list 'treesit-fold-range-alist '(web-mode . (html-mode
                                                       (element . treesit-fold-range-html)
                                                       (comment treesit-fold-range-seq 1 -1))))

  (add-to-list 'treesit-fold-range-alist '(ng2-html-mode . (html-mode
                                                            (element . treesit-fold-range-html)
                                                            (comment treesit-fold-range-seq 1 -1))))
  (add-to-list 'treesit-fold-range-alist '(scss-mode . ((keyframe_block_list . ts-fold-range-seq)
                                                        (block . treesit-fold-range-seq)
                                                        (comment . treesit-fold-range-c-like-comment))) t)


  (add-to-list 'treesit-fold-range-alist
               '(typescript-ts-mode
                 .
                 ((export_clause . ts-fold-range-seq)
                  (statement_block . treesit-fold-range-seq)
                  (comment . treesit-fold-range-c-like-comment)
                  (array . treesit-fold-range-seq)
                  (object . treesit-fold-range-seq))))

  (add-to-list 'treesit-fold-range-alist `(typescript-ts-mode . ,(treesit-fold-parsers-typescript)))
  (add-to-list 'treesit-fold-range-alist `(go-ts-mode . ,(treesit-fold-parsers-go)))

  ;; TODO: DOESN'T WORK for scss, needs another rules (check it later for custom pareser)
  (add-to-list 'treesit-fold-range-alist '(scss-mode . (css-mode
                                                        (keyframe_block_list . treesit-fold-range-seq)
                                                        (block . treesit-fold-range-seq)
                                                        (comment . treesit-fold-range-c-like-comment)))))


#+END_SRC
** Apheleia formatter (prettier)
Another all formtter. Based on prettier and black
#+BEGIN_SRC emacs-lisp
(use-package apheleia
  :hook (prog-mode . apheleia-global-mode)
  :bind (:map meow-normal-state-keymap
              ("\\p" . apheleia-format-buffer))
  :config
  (setf (alist-get 'kdlfmt apheleia-formatters)
        '("kdlfmt" "format" "-"))
  (add-to-list 'apheleia-mode-alist '(kdl-mode . kdlfmt))

  (add-to-list 'apheleia-mode-alist '(emacs-lisp-mode . lisp-indent))
  (add-to-list 'apheleia-mode-alist '(html-ts-mode . prettier))
  (add-to-list 'apheleia-mode-alist '(vue-ts-mode . prettier))
  (add-to-list 'apheleia-mode-alist '(html-mode . prettier)))
#+END_SRC
** Case converter
Allow to transform PASCAL_CASE -> camelCase -> snake_case
#+BEGIN_SRC emacs-lisp
(use-package string-inflection
  :bind ("s-C" . string-inflection-all-cycle))
#+END_SRC
* File management
** Functions
*** Open configuration file
#+BEGIN_SRC emacs-lisp
(defun my/open-emacs-config ()
  "Open folder with emacs config"
  (interactive)
  (let ((default-directory my/config-file))
    (call-interactively 'find-file)))
#+END_SRC

*** Find configuration file
#+BEGIN_SRC emacs-lisp :results silent
(defun my/open-config-file ()
  "Finc dot file"
  (interactive)
  (let ((default-directory my/config-dir))
    (call-interactively 'project-find-file)))
#+END_SRC

** Dired
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package dired
  :defer t
  :ensure nil
  :bind (:map dired-mode-map
              ("z z" . recenter)
              ("-" . dired-up-directory)
              ("\\c" . dired-create-empty-file))
  :config
  (setq dired-dwim-target t)
  ;; Use GNU ls if available (install via: brew install coreutils)
  (when (executable-find "gls")
    (setq insert-directory-program "gls" dired-use-ls-dired t))
  (add-hook 'dired-mode-hook 'auto-revert-mode))
#+END_SRC
*** Dired icons
#+BEGIN_SRC emacs-lisp
(use-package nerd-icons-dired
  :hook (dired-mode . nerd-icons-dired-mode))
#+END_SRC

** File info. Information about currently opened file
#+BEGIN_SRC emacs-lisp
(use-package file-info
  :bind ("s-'" . file-info-show)
  :defer t
  :config
  (setq hydra-hint-display-type 'posframe)
  (setq hydra-posframe-show-params '(:poshandler posframe-poshandler-frame-center
                                                 :internal-border-width 2
                                                 :internal-border-color "#61AFEF"
                                                 :left-fringe 16
                                                 :right-fringe 16)))
#+END_SRC
** Reveal in osx finder
#+BEGIN_SRC emacs-lisp
(use-package reveal-in-osx-finder
  :defer t
  :bind (("C-c o f" . reveal-in-osx-finder))
  :ensure t)
#+END_SRC

** Dirvish.
#+BEGIN_SRC emacs-lisp
(use-package dirvish
  :init
  (dirvish-override-dired-mode)
  :bind (("C-c o p" . dirvish-side)
         ("C-c f g" . dirvish-quick-access)
         :map dirvish-mode-map
         ("f" . avy-goto-word-1)
         ("r" . dirvish-file-info-menu)
         :map meow-normal-state-keymap
         ("gf" . dirvish-quick-access))
  :custom
  (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
   `(("h" "~/"                          "Home")
     ("d" "~/Downloads/"                "Downloads")
     ("p" "~/projects/pet"              "Pet")
     ("o" "~/projects/pet/orgnote"      "Orgnote")
     ("s" "~/Pictures/screenshots"      "Screenshots")
     ("e" "~/projects/pet/emacs"        "Emacs")
     ("a" ,my/agenda-dir                "Agenda")))
  (dirvish-side-width 45)
  (dirvish-side-attributes '(vc-state subtree-state file-name collapse))
  (dirvish-default-layout '(0 0.35 0.65))
  (dirvish-emerge-group '(("Recent files"  (predicate . recent-files-2h))
                          ("Documents"     (extensions "pdf" "tex" "bib" "epub"))
                          ("Video"         (extensions "mp4" "mkv" "webm"))
                          ("Pictures"      (extensions "jpg" "png" "svg" "gif"))
                          ("Audio"         (extensions "mp3" "flac" "wav" "ape" "aac"))
                          ("Archives"      (extensions "gz" "rar" "zip"))))

  :config
  (setq dirvish-attributes
        '(file-time collapse subtree-state))
  (setq delete-by-moving-to-trash t)
  :bind
  (:map dirvish-mode-map
        ("q" . dirvish-quit)
        :map dired-mode-map ; Dirvish respects all the keybindings in this map
        ("q" . dirvish-quit)
        ("h" . dired-up-directory)
        ("j" . dired-next-line)
        ("k" . dired-previous-line)
        ("l" . dired-find-file)
        ("i" . wdired-change-to-wdired-mode)
        ("." . dired-omit-mode)
        ("b"   . dirvish-bookmark-jump)
        ("f"   . dirvish-file-info-menu)
        ("y"   . dirvish-yank-menu)
        ("N"   . dirvish-narrow)
        ("^"   . dirvish-history-last)
        ("s"   . dirvish-quicksort) ; remapped `dired-sort-toggle-or-edit'
        ("?"   . dirvish-dispatch)  ; remapped `dired-summary'
        ("TAB" . dirvish-subtree-toggle)
        ("M-n" . dirvish-history-go-forward)
        ("M-p" . dirvish-history-go-backward)
        ("M-l" . dirvish-ls-switches-menu)
        ("M-m" . dirvish-mark-menu)
        ("M-f" . dirvish-toggle-fullscreen)
        ("M-s" . dirvish-setup-menu)
        ("M-e" . dirvish-emerge-menu)
        ("M-j" . dirvish-fd-jump)))
#+END_SRC
* Terminal
** Functions
*** Clear history
#+BEGIN_SRC emacs-lisp
(defun my/clear-term-history ()
  "Clear terminal history inside vterm."
  (interactive)
  (when (eq major-mode 'vterm-mode)
    (vterm--self-insert)
    (vterm-send-string "clear")
    (vterm-send-return)))
#+END_SRC

*** Open in current buffer
#+BEGIN_SRC emacs-lisp
(defun my/vterm-open-here ()
  "Open vterm inside current buffer."
  (interactive)
  (let ((bn vterm-buffer-name))
    (if (get-buffer bn)
        (switch-to-buffer bn)
      (project-vterm))))
#+END_SRC
*** Open vterm for current buffer
#+BEGIN_SRC emacs-lisp :results silent
(defun my/vterm--get-dir ()
  (expand-file-name
   (or (when-let ((f (buffer-file-name)))
         (file-name-directory f))
       (when-let ((p (project-current)))
         (project-root p))
       default-directory)))

(defun my/vterm--cd (buf dir)
  (with-current-buffer buf
    (when (get-buffer-process buf)
      (vterm-send-C-c))
    (vterm-send-string (concat "cd " (shell-quote-argument dir)))
    (vterm-send-key "<return>")))

(defun my/vterm-right ()
  (interactive)
  (let* ((dir (my/vterm--get-dir))
         (buf (or (get-buffer "*vterm")
                  (save-window-excursion (multi-vterm-project))))
         (win (or (window-in-direction 'right)
                  (split-window-right))))
    (select-window win)
    (switch-to-buffer buf)
    (my/vterm--cd buf dir)))
#+END_SRC

** Vterm
#+BEGIN_SRC emacs-lisp
(use-package vterm
  :defer t
  :bind (("C-c o V" . my/vterm-open-here)
         ("C-c o T" . my/vterm-cd)
         ("C-c o R" . my/vterm-right)
         :map vterm-mode-map
         ("C-u" . vterm--self-insert)
         ("C-c m c" . vterm-copy-mode))
  :custom
  (vterm-max-scrollback 5000)
  (vterm-shell (or
                (executable-find "/Users/darkawower/.nix-profile/bin/xonsh")
                (executable-find "/home/darkawower/.nix-profile/bin/xonsh")
                (executable-find "xonsh")))
  :config
  (setq vterm-clear-scrollback t)
  (advice-add 'vterm-clear-scrollback :before #'my/clear-term-history))
#+END_SRC

** Toggle vterm
#+BEGIN_SRC emacs-lisp
(use-package vterm-toggle
  :defer t
  :commands (vterm-toggle-show)
  :bind (("C-c o t" . vterm-toggle))
  :config
  (setq vterm-always-compile-module t)
  (setq vterm-kill-buffer-on-exit nil)
  (setq vterm-toggle-scope 'project)
  (setq vterm-toggle-fullscreen-p nil)

  (add-to-list 'display-buffer-alist
               '((lambda (buffer-or-name _)
                   (let ((buffer (get-buffer buffer-or-name)))
                     (with-current-buffer buffer
                       (and (string-match-p "^\\*vterm" (buffer-name buffer))
                            (or (eq major-mode 'vterm-mode)
                                (string-prefix-p vterm-buffer-name (buffer-name buffer)))))))
                 (display-buffer-reuse-window display-buffer-at-bottom)
                 (reusable-frames . visible)
                 (window-height . 0.3))))
#+END_SRC

** Multi vterm
#+BEGIN_SRC emacs-lisp :results silent
(use-package multi-vterm
  :bind (("C-c o v" . multi-vterm-project)))
#+END_SRC
** Detached. Background commands
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package detached
  :defer t
  :init
  (detached-init)
  :bind (([remap compile] . detached-compile)
         ([remap recompile] . detached-compile-recompile)
         ([remap project-compile] . detached-compile)
         ([remap project-recompile] . detached-compile-recompile)
         ([remap detached-open-session] . detached-consult-session)
         ("C-c D v" . detached-view-session)
         ("C-c D k" . detached-kill-session)
         ("C-c D a" . detached-rerun-session)
         ("C-c D R" . my/detached-restart-session)
         ("C-c D r" . detached-compile-recompile)
         ("C-c D c" . detached-compile))
  :custom
  (detached-show-output-on-attach t)
  (detached-terminal-data-command system-type))
#+END_SRC

*** Force restart session
#+BEGIN_SRC emacs-lisp :results silent
(defun my/detached-restart-session ()
  (interactive)
  (let ((session (detached-session-in-context)))
    (when (and session (detached-session-active-p session))
      (detached-kill-session session)
      (sleep-for 0.2)
      (when (detached-session-active-p session)
        (detached-session-kill session)))
    (detached-rerun-session session)))
#+END_SRC
* Git
** Magit
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands
  (magit-get-current-branch)
  :bind
  (("C-M-g" . magit-status)
   ("C-M-S-d" . magit-ediff-compare)
   ("C-M-S-c" . magit-commit)
   ("C-M-S-a" . my/magit-stage-current-file)
   ("C-M-d" . my/magit-ediff-current-file-against-head)
   ("C-c g g" . magit-status)
   :map magit-mode-map
   ("C-1" . magit-section-show-level-1)
   ("C-2" . magit-section-show-level-2)
   ("C-3" . magit-section-show-level-3)
   ("C-j" . magit-section-forward)
   ("C-k" . magit-section-backward)
   ("C-4" . magit-section-show-level-4)
   ("q" . kill-current-buffer)
   ("<escape>" . kill-current-buffer)
   ("Q" . bury-buffer)
   (";" . meow-reverse)
   ("Z" . magit-stash)
   ("P" . magit-fetch)
   ("p" . magit-push)
   ("`" . magit-process-buffer)
   ("f" . avy-goto-word-1)
   ("x" . magit-discard)
   :map magit-status-mode-map
   ("x" . meow-line)
   ("X" . magit-discard)
   ("z z" . recenter)
   ("C-j" . magit-section-forward)
   ("C-k" . magit-section-backward)
   ("M-n" . husky-lsp-repeat-consult-search-forward)
   ("M-p" . husky-lsp-repeat-consult-search-backward)
   :map magit-diff-mode-map
   ("C-j" . magit-section-forward)
   ("C-k" . magit-section-backward))
  :custom-face
  (git-commit-overlong-summary ((t :inherit error :weight bold)))
  :custom
  (magit-diff-visit-prefer-worktree t)
  (magit-ediff-dwim-show-on-hunks t)
  (magit-diff-refine-hunk t)
  (magit-process-timestamp-format "%H:%M")
  (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)
  (magit-process-finish-apply-ansi-colors t)
  :hook
  (magit-process-mode . compilation-minor-mode)
  :config
  ;; Reset magit numbers
  (dolist (key (mapcar (lambda (n) (kbd (number-to-string n))) (number-sequence 0 9)))
    (define-key magit-mode-map key nil)
    (define-key magit-status-mode-map key nil))
  (define-key transient-map        "q" 'transient-quit-one)
  (define-key transient-edit-map   "q" 'transient-quit-one)
  (define-key transient-sticky-map "q" 'transient-quit-seq)
  (define-key magit-file-section-map (kbd "C-j") 'magit-section-forward)
  (define-key magit-hunk-section-map (kbd "C-j") 'magit-section-forward)
  (setcdr magit-process-mode-map (cdr (make-keymap)))
  (set-keymap-parent magit-process-mode-map special-mode-map))
#+END_SRC

*** Helper functions
**** Stage current file
#+BEGIN_SRC emacs-lisp :results silent
(defun my/magit-stage-current-file ()
  "Stage current file in Magit."
  (interactive)
  (magit-file-stage)
  (when (featurep 'git-gutter)
    (git-gutter)))

#+END_SRC
**** Open git diff for current blame line
#+BEGIN_SRC emacs-lisp
(defun my/magit-show-commit-at-point ()
  "Open Magit revision for commit that last modified the current line."
  (interactive)
  (let* ((file (buffer-file-name))
         (line (line-number-at-pos))
         (hash (string-trim
                (shell-command-to-string
                 (format "git blame -L %d,%d --porcelain %s | sed -n '1s/ .*//p'"
                         line line file)))))
    (if (string-match-p "^[0-9a-f]\\{7,40\\}$" hash)
        (magit-show-commit hash)
      (message "No commit found for current line."))))
#+END_SRC
**** Show di
#+BEGIN_SRC emacs-lisp :results silent
(defun my/magit-ediff-current-file-against-head ()
  (interactive)
  (let* ((abs (or (and (fboundp 'magit-file-at-point) (magit-file-at-point))
                  (buffer-file-name)))
         (top (and abs (magit-toplevel)))
         (rel (and top (magit-file-relative-name abs))))
    (unless rel (user-error "Ð¤Ð°Ð¹Ð» Ð½Ðµ Ð² git-Ð¿Ñ€Ð¾ÐµÐºÑ‚Ðµ"))
    (let* ((bufA (generate-new-buffer (format "*HEAD:%s*" rel)))
           (bufB (find-file-noselect abs))
           (mode (buffer-local-value 'major-mode bufB))
           (ok (with-current-buffer bufA
                 (let ((default-directory top))
                   (erase-buffer)
                   (eq 0 (call-process "git" nil t nil "show" (concat "HEAD:" rel)))))))
      (unless ok (kill-buffer bufA) (user-error "git show HEAD:%s failed" rel))
      (with-current-buffer bufA (funcall mode))
      (let ((ctl (ediff-buffers bufA bufB)))
        (when (buffer-live-p ctl)
          (with-current-buffer ctl
            (add-hook 'ediff-quit-hook (lambda () (when (buffer-live-p bufA) (kill-buffer bufA))) nil t)))))))
#+END_SRC
*** Magit todos
#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :bind (("C-c g n" . magit-todos-list)
         ("C-c l T" . magit-todos-list)
         ("C-c t l" . magit-todos-list)))
#+END_SRC

*** Visit next dirty file
#+BEGIN_SRC emacs-lisp :results silent
(defun my/git-visit-next-dirty-file ()
  "Switch to next buffer visiting a Git unstaged or untracked file."
  (interactive)
  (require 'vc-git)
  (let* ((repo-root (vc-git-root default-directory)))
    (unless repo-root
      (user-error "Not inside a Git repository"))
    (let* ((root (expand-file-name repo-root))
           (status-output
            (shell-command-to-string
             (format "git -C %s status --porcelain=v1"
                     (shell-quote-argument root))))
           ;; Collect interesting files
           (interesting-files
            (let (files)
              (dolist (line (split-string status-output "\n" t))
                (when (> (length line) 3)
                  (let ((status (substring line 0 2))
                        (path   (substring line 3)))
                    ;; include:
                    ;; ??  untracked
                    ;;  M  unstaged
                    ;; MM  staged + unstaged
                    (when (or (string= status "??")
                              (string= status " M")
                              (string= status "MM"))
                      ;; handle rename: "old -> new"
                      (when (string-match " -> " path)
                        (setq path (cadr (split-string path " -> " t))))
                      (push (expand-file-name path root) files)))))
              files))
           (buffers (buffer-list))
           (start (current-buffer))
           (rotated (append (cdr (memq start buffers)) buffers)))
      (catch 'done
        (dolist (buf rotated)
          (let ((file (buffer-file-name buf)))
            (when (and file
                       (member (expand-file-name file) interesting-files))
              (switch-to-buffer buf)
              (throw 'done t))))
        (message "No unstaged or untracked Git buffers")))))
#+END_SRC
** Git gutter
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :hook (emacs-startup . global-git-gutter-mode)
  :bind (("C-M-[" . git-gutter:previous-hunk)
         ("C-M-]" . git-gutter:next-hunk)
         ("C-M-r" . git-gutter:revert-hunk)
         ("C-M-s" . git-gutter:stage-hunk)
         :map meow-normal-state-keymap
         ("g]" . git-gutter:next-hunk)
         ("g[" . git-gutter:previous-hunk))
  :custom
  (git-gutter:update-interval 2)
  :config
  (setq git-gutter:added-sign " "
        git-gutter:modified-sign " "
        git-gutter:deleted-sign " ")
  (setq git-gutter:window-width 1))
#+END_SRC

*** Better gitgutter fringe :ui:
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :config
  (git-gutter-mode 1)
  (require 'cl-lib)

  (defmacro git-gutter-fr-define-glyph (count pattern)
    `(progn
       ,@(cl-loop
          for kind in '(added modified deleted)
          collect
          `(fringe-helper-define
             ',(intern (format "git-gutter-fr:%s" kind))
             nil
             ,@(cl-loop repeat count collect pattern)))))

  (git-gutter-fr-define-glyph 30 "XX...."))
#+END_SRC

** Blamer
Disable function
#+BEGIN_SRC emacs-lisp :results silent
(defun my/disable-blamer-mode ()
  "Disable blamer mode in current buffer."
  (interactive)
  (blamer-mode -1))

#+END_SRC

Setup blamer face

#+BEGIN_SRC emacs-lisp :results silent
(defun my/setup-blamer-face ()
  "Setup blamer face according to my font settings."
  (interactive)
  (set-face-attribute 'blamer-face nil
                      :inherit 'font-lock-comment-face
                      :italic t
                      :font (format "%s %d" my/font-comic my/font-height)
                      :height 0.8
                      :background 'unspecified))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package blamer
  :defer t
  :ensure (:host github :repo "artawower/blamer.el" :branch "fix/async-overlays")
  :hook
  (prog-mode . blamer-mode)
  (meow-insert-mode . my/disable-blamer-mode)
  (meow-normal-mode . blamer-mode)
  (after-load-theme-hook . my/setup-blamer-face)
  ;; From MELPA, uncomment below for development version:
  ;; :ensure (:type git :host github :repo "artawower/blamer.el" :branch "fix/emacs-buffers-spawns")
  :bind (("C-c b i" . blamer-show-commit-info)
         ("C-c b h" . (lambda () (interactive) (blamer-show-commit-info 'visual)))
         ("s-i" . blamer-show-posframe-commit-info))
  :custom
  (blamer-idle-time 0.8)
  (blamer-min-offset 20)
  (blamer-max-commit-message-length 65)
  (blamer-commit-formatter "â—‰ %s")
  (blamer-view 'overlay)
  (blamer-uncommitted-changes-message "uncommitted yet")
  (blamer-tooltip-function 'blamer-tooltip-commit-message)
  :config
  ;; Setup face with font variables
  (my/setup-blamer-face)


  (defun blamer-callback-show-commit-diff (commit-info)
    (interactive)
    (let ((commit-hash (plist-get commit-info :commit-hash)))
      (when commit-hash
        (magit-show-commit commit-hash))))

  (defun blamer-callback-open-remote (commit-info)
    (interactive)
    (let ((commit-hash (plist-get commit-info :commit-hash)))
      (when commit-hash
        (forge-browse-commit commit-hash))))

  (setq blamer-bindings '(("<mouse-3>" . blamer-callback-open-remote)
                          ("<mouse-1>" . blamer-callback-show-commit-diff))))
#+END_SRC

** Ediff
*** Helper functions
**** Face setup
#+BEGIN_SRC emacs-lisp
(defun my/ediff-faces-setup ()
  "Make Ediff faces copy exact colors from Diff faces."
  (let* ((add-bg (face-attribute 'diff-added :background nil 'default))
         (add-fg (face-attribute 'diff-added :foreground nil 'default))
         (rem-bg (face-attribute 'diff-removed :background nil 'default))
         (rem-fg (face-attribute 'diff-removed :foreground nil 'default))
         (chg-bg (if (facep 'diff-changed)
                     (face-attribute 'diff-changed :background nil 'default)
                   add-bg))
         (chg-fg (if (facep 'diff-changed)
                     (face-attribute 'diff-changed :foreground nil 'default)
                   add-fg))
         (radd-bg (if (facep 'diff-refine-added)
                      (face-attribute 'diff-refine-added :background nil 'default)
                    add-bg))
         (radd-fg (if (facep 'diff-refine-added)
                      (face-attribute 'diff-refine-added :foreground nil 'default)
                    add-fg))
         (rrem-bg (if (facep 'diff-refine-removed)
                      (face-attribute 'diff-refine-removed :background nil 'default)
                    rem-bg))
         (rrem-fg (if (facep 'diff-refine-removed)
                      (face-attribute 'diff-refine-removed :foreground nil 'default)
                    rem-fg))
         (rchg-bg (if (facep 'diff-refine-changed)
                      (face-attribute 'diff-refine-changed :background nil 'default)
                    radd-bg))
         (rchg-fg (if (facep 'diff-refine-changed)
                      (face-attribute 'diff-refine-changed :foreground nil 'default)
                    radd-fg)))
    (set-face-attribute 'ediff-current-diff-A nil :inherit nil :background rem-bg :foreground rem-fg :extend t)
    (set-face-attribute 'ediff-current-diff-B nil :inherit nil :background add-bg :foreground add-fg :extend t)
    (set-face-attribute 'ediff-current-diff-C nil :inherit nil :background chg-bg :foreground chg-fg :extend t)
    (set-face-attribute 'ediff-fine-diff-A    nil :inherit nil :background rrem-bg :foreground rrem-fg :extend t)
    (set-face-attribute 'ediff-fine-diff-B    nil :inherit nil :background radd-bg :foreground radd-fg :extend t)
    (set-face-attribute 'ediff-fine-diff-C    nil :inherit nil :background rchg-bg :foreground rchg-fg :extend t)
    (dolist (f '(ediff-even-diff-A ediff-even-diff-B ediff-even-diff-C
                                   ediff-odd-diff-A ediff-odd-diff-B ediff-odd-diff-C
                                   ediff-current-diff-Ancestor ediff-even-diff-Ancestor
                                   ediff-odd-diff-Ancestor ediff-fine-diff-Ancestor))
      (set-face-attribute f nil :inherit 'default :foreground 'unspecified :background 'unspecified :extend t))))
#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :ensure nil
  :defer t
  :config
  ;; ediff inherit from diff-added, diff removed and diff base
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function #'split-window-horizontally)
  (setq ediff-highlight-all-diffs t)

  (add-hook 'ediff-load-hook #'my/ediff-faces-setup)
  (add-hook 'ediff-prepare-buffer-hook (lambda () (toggle-truncate-lines -1)))
  (add-hook 'ediff-prepare-buffer-hook #'display-line-numbers-mode)
  ;; (add-hook 'ediff-load-hook #'zoom-mode)
  (add-hook 'ediff-cleanup-hook
            (lambda ()
              (dolist (buf (list ediff-buffer-A ediff-buffer-B
                                 (when (boundp 'ediff-buffer-C) ediff-buffer-C)))
                (when (buffer-live-p buf)
                  (with-current-buffer buf
                    (display-line-numbers-mode -1)))))))
              ;; (zoom-mode))))
#+END_SRC

** Timemachine
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :hook (git-timemachine-mode . font-lock-mode)
  :bind (("C-M-t" . git-timemachine)
         ("C-M-m" . git-timemachine)
         :map git-timemachine-mode-map
         ("C-k" . git-timemachine-show-previous-revision)
         ("q" . git-timemachine-quit)
         ("<escape>" . git-timemachine-quit)
         ("Q" . git-timemachine-quit)
         ("C-j" . git-timemachine-show-next-revision)))
#+END_SRC

** Smerge
#+BEGIN_SRC emacs-lisp
(use-package smerge-mode
  :ensure nil
  :bind (:map smerge-mode-map
         ("C-c C-l" . smerge-keep-lower)
         ("C-c C-u" . smerge-keep-upper)
         ("C-c C-a" . smerge-keep-all)
         ("C-c C-j" . smerge-next)
         ("C-c C-k" . smerge-prev)
         :map meow-normal-state-keymap
         ("g s" . smerge-next)
         ("g S" . smerge-prev))
  :config
  (defun my/smerge-keep-n-fix (fn n)
    (let ((inhibit-modification-hooks t))
      (smerge-match-conflict)
      (funcall fn n)))
  (advice-add 'smerge-keep-n :around #'my/smerge-keep-n-fix))
#+END_SRC

** Browse at remote
#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :bind (("C-c o r" . browse-at-remote)))
#+END_SRC
* Workspace
** Buffer navigation Functions
#+BEGIN_SRC emacs-lisp
(defun my/tabspaces--internal-buffer-p (buf)
  "Return non-nil if BUF is internal (minibuffer or name starts with a space)."
  (or (minibufferp buf)
      (let ((n (buffer-name buf)))
        (and n (> (length n) 0) (eq (aref n 0) ?\s)))))

(defun my/tabspaces--allowed-p (buf)
  "Return non-nil if BUF belongs to the current tabspace and is not internal."
  (and (memq buf (tabspaces--buffer-list))
       (buffer-live-p buf)
       (not (my/tabspaces--internal-buffer-p buf))))

(defun my/tabspaces-switch-to-prev-buffer ()
  "Like `switch-to-prev-buffer' but stay within the current tabspace.
Falls back to `switch-to-prev-buffer' if `tabspaces-mode' is not active."
  (interactive)
  (if (bound-and-true-p tabspaces-mode)
      (let ((start (current-buffer))
            ;; Safety to avoid infinite loops in degenerate histories.
            (limit 100)
            (found nil))
        (while (and (> limit 0) (not found))
          (setq limit (1- limit))
          (switch-to-prev-buffer)
          (setq found (or (eq (current-buffer) start) ; wrapped around
                          (my/tabspaces--allowed-p (current-buffer)))))
        (unless (my/tabspaces--allowed-p (current-buffer))
          (switch-to-buffer start)
          (user-error "No previous buffer in this tabspace")))
    (call-interactively #'switch-to-prev-buffer)))

(defun my/tabspaces-switch-to-next-buffer ()
  "Like `switch-to-next-buffer' but stay within the current tabspace.
Falls back to `switch-to-next-buffer' if `tabspaces-mode' is not active."
  (interactive)
  (if (bound-and-true-p tabspaces-mode)
      (let ((start (current-buffer))
            (limit 100)
            (found nil))
        (while (and (> limit 0) (not found))
          (setq limit (1- limit))
          (switch-to-next-buffer)
          (setq found (or (eq (current-buffer) start)
                          (my/tabspaces--allowed-p (current-buffer)))))
        (unless (my/tabspaces--allowed-p (current-buffer))
          (switch-to-buffer start)
          (user-error "No next buffer in this tabspace")))
    (call-interactively #'switch-to-next-buffer)))
#+END_SRC

** Safe kill tab for daemon mode
#+BEGIN_SRC emacs-lisp
(defun my/safe-tabspaces-kill-buffers-close-workspace ()
  "Safely kill buffers and close workspace.
Prevents closing the last frame in daemon mode on macOS."
  (interactive)
  (let ((tab-count (length (tab-bar-tabs)))
        (frame-count (length (frame-list))))
    (cond
     ((and (daemonp)
           (= tab-count 1)
           (= frame-count 1))
      (message "Cannot close the last workspace in daemon mode. Killing buffers only.")
      (tabspaces-clear-buffers))
     ((= tab-count 1)
      (message "Closing last tab in this frame...")
      (tabspaces-kill-buffers-close-workspace))
     (t
      (tabspaces-kill-buffers-close-workspace)))))
#+END_SRC

** Core package. Tabspaces
#+BEGIN_SRC emacs-lisp
(use-package tabspaces
  :ensure (:type git :host github :repo "mclear-tools/tabspaces")
  :commands (tabspaces-switch-or-create-workspace
             tabspaces-open-or-create-project-and-workspace)
  :bind (("s-1" . (lambda () (interactive) (tab-bar-select-tab 1)))
         ("s-2" . (lambda () (interactive) (tab-bar-select-tab 2)))
         ("s-3" . (lambda () (interactive) (tab-bar-select-tab 3)))
         ("s-4" . (lambda () (interactive) (tab-bar-select-tab 4)))
         ("s-5" . (lambda () (interactive) (tab-bar-select-tab 5)))
         ("s-6" . (lambda () (interactive) (tab-bar-select-tab 6)))
         ("C-c b0" . tabspaces-clear-buffers)
         ("C-c TAB p" . tabspaces-open-or-create-project-and-workspace)
         ("C-c TAB n" . tabspaces-switch-or-create-workspace)
         ("C-c bt" . tabspaces-switch-to-buffer)
         ("C-c TAB b" . tabspaces-switch-to-buffer)
         ("C-c TAB B" . switch-to-buffer)
         ("s-w" . delete-window)
         ("C-c TAB d" . my/safe-tabspaces-kill-buffers-close-workspace)
         ("C-c TAB S" . tabspaces-save-current-project-session)
         ("C-c TAB s" . tabspaces-save-session)
         ("C-c TAB r" . tab-rename)
         ("C-c TAB l" . tabspaces-restore-session)
         ("C-c ]" . my/tabspaces-switch-to-next-buffer)
         ("C-c [" . my/tabspaces-switch-to-prev-buffer))
  :custom
  (tabspaces-mode 1)
  (tab-bar-new-tab-choice "*scratch*")
  (tabspaces-remove-to-default t)
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "README.org")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '())
  (tabspaces-initialize-project-with-todo nil)
  (tabspaces-todo-file-name "project-todo.org")
  ;; sessions
  (tabspaces-session nil)
  (tabspaces-session-auto-restore nil))
#+END_SRC
** Tab bar
#+BEGIN_SRC emacs-lisp
(use-package tab-bar
  :defer t
  :bind (("C-c TAB w" . tab-switch)
         ("C-c w w" . tab-switch))
  :ensure nil
  :custom
  (tab-bar-show nil))
#+END_SRC

** Project.el
#+BEGIN_SRC emacs-lisp
(use-package project
  :after meow
  :ensure nil
  :bind (("C-c p p" . project-switch-project)
         ("C-c p d" . project-forget-project)
         ("C-c SPC" . project-find-file)
         ("C-c f f" . project-find-file)
         ("C-c f d" . project-find-dir)
         ("C-c p c" . project-compile)
         ("C-c p r" . project-recompile)
         ("C-c p v" . my/show-compilation-buffer)
         ("C-c p b" . project-switch-to-buffer)))
#+END_SRC

** Ibuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :defer t
  :ensure nil
  :bind ("C-c i b" . ibuffer))
#+END_SRC
*** Icons
#+BEGIN_SRC emacs-lisp
(use-package nerd-icons-ibuffer
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

#+END_SRC

* Completion
** Vertico
*** Helper functions
#+BEGIN_SRC emacs-lisp
(defun my/vertico-insert-home ()
  "Kill line and insert home directory."
  (interactive)
  (kill-whole-line)
  (insert "~/"))

(defun my/vertico-insert-root ()
  "Kill line and insert root directory."
  (interactive)
  (kill-whole-line)
  (insert "/"))
#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :ensure (:host github :repo "minad/vertico" :files ("vertico.el" "extensions/*.el"))
  :init
  ;; Add prompt indicator to `completing-read-multiple'
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t)

  :hook (emacs-startup-hook . vertico-mode)
  :bind (("C-c ;" . vertico-repeat-last)
         ("C-c '" . vertico-repeat)
         :map vertico-map
         ("C-j" . vertico-next)
         ("C-k" . vertico-previous)
         ("C-n" . vertico-next-group)
         ("C-p" . vertico-previous-group)
         ("C-l" . vertico-quick-jump)
         ("C-o" . embark-act)
         ("C-q" . vertico-exit-input)
         ("C-n" . vertico-next-group)
         ("C-p" . vertico-previous-group)
         ("<escape>" . abort-minibuffers)
         ("C-d" . my/vertico-insert-home)
         ("C-r" . my/vertico-insert-root))
  :custom
  (vertico-cycle t)
  (read-file-name-completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  (completion-ignore-case t)
  :config
  (set-face-attribute 'vertico-current nil :inherit 'region)
  (vertico-mouse-mode 1)
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if (and vertico-mode
                          (fboundp 'consult-completion-in-region))
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args))))

#+END_SRC

*** Vertico repeat
#+BEGIN_SRC emacs-lisp
(use-package vertico-repeat
  :ensure nil
  :after vertico
  :hook (minibuffer-setup . vertico-repeat-save))

#+END_SRC

*** Orderless
#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

#+END_SRC

*** Save hist
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode))
#+END_SRC
*** Bulk grep operation
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :bind ("C-c C-w" . wgrep-change-to-wgrep-mode))
#+END_SRC

** Embark
*** Copy grep result action
#+NAME: embark-content-copy-function
#+BEGIN_SRC emacs-lisp  :tangle no
(defun copy-grep-results-as-kill (strings)
  (embark-copy-as-kill
   (mapcar (lambda (string)
             (substring string
                        (1+ (next-single-property-change
                             (1+ (next-single-property-change 0 'face string))
                             'face string))))
           strings)))

(add-to-list 'embark-multitarget-actions 'copy-grep-results-as-kill)

(defvar-keymap embark-consult-grep-map
  :doc "Keymap for actions for consult-grep results."
  :parent embark-general-map
  "w" #'copy-grep-results-as-kill)

(setf (alist-get 'consult-grep embark-keymap-alist) 'embark-consult-grep-map)
#+END_SRC
*** Embark preview function
#+BEGIN_SRC emacs-lisp
(defun my/vertico-embark-preview ()
  "Previews candidate in vertico buffer, unless it's a consult command"
  (interactive)
  (unless (bound-and-true-p consult--preview-function)
    (save-selected-window
      (let ((embark-quit-after-action nil))
        (embark-dwim)))))
#+END_SRC
*** Core package
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package embark
  :custom
  (embark-indicators '(embark-minimal-indicator embark-highlight-indicator embark-isearch-highlight-indicator))
  (prefix-help-command #'embark-prefix-help-command)
  :bind
  (("C-." . embark-act)
   ("C-;" . embark-dwim)
   ("C-h B" . embark-bindings)
   :map minibuffer-local-map
   ("C-SPC" . my/vertico-embark-preview)
   ("C-u" . my/backward-kill-line)
   :map read--expression-map
   ("C-SPC" . my/vertico-embark-preview)
   ("C-u" . my/backward-kill-line)
   :map vertico-map
   ("C-SPC" . my/vertico-embark-preview)
   ("C-u" . my/backward-kill-line))

  :config
  (add-to-list 'display-buffer-alist '("^\\*Embark Export\\*$" (display-buffer-in-side-window) (window-height . 0.4)))
  <<embark-content-copy-function>>)
#+END_SRC

*** Embark consult
#+BEGIN_SRC emacs-lisp
;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC
** Completion annotations marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :hook (emacs-startup . marginalia-mode)
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    :config
    (pushnew! marginalia-command-categories
            '(+default/find-file-under-here . file)
            '(flycheck-error-list-set-filter . builtin)
            '(persp-switch-to-buffer . buffer)))

#+END_SRC

** Consult
*** Helper functions
**** Search in line or region
Function for search in buffer depends or visual or normal line
#+BEGIN_SRC emacs-lisp
(defun my/consult-line-or-region ()
  "Search in buffer depends or visual or normal line"
  (interactive)
  (if (region-active-p)
      (let ((substring (buffer-substring (region-beginning) (region-end))))
        (deactivate-mark)
        (consult-line substring))
    (consult-line)))
#+END_SRC
**** Consult ripgrep selected
#+BEGIN_SRC emacs-lisp :results silent
(defun my/consult-ripgrep-selected-p ()
  "Run `consult-ripgrep' on selected region, or with empty string"
  (interactive)
  (if (use-region-p)
      (consult-ripgrep nil (buffer-substring (region-beginning) (region-end)))
    (consult-ripgrep)))
#+END_SRC

*** Core package
#+BEGIN_SRC emacs-lisp
(use-package consult
  :bind (("s-f" . my/consult-line-or-region)
         ("C-c b b" . consult-buffer-other-tab)
         ("C-c b a" . consult-buffer)
         ("C-c b b" . consult-project-buffer)
         ("C-c f C" . my/open-config-file)
         ("C-c f P" . my/open-emacs-config)
         ("C-c f p" . consult-ripgrep)
         ("C-c *" . (lambda () (interactive) (consult-ripgrep nil (thing-at-point 'symbol))))
         ("C-c /" . my/consult-ripgrep-selected-p)
         ("C-c f o" . my/consult-ripgrep-selected-p)
         ("C-c s i" . consult-imenu)
         ("C-c RET" . consult-bookmark)
         ("C-c c m" . consult-mark)
         ("C-c f r" . consult-recent-file)
         ("C-c f R" . consult-recent-file))
  :custom
  (consult-preview-key "C-SPC")
  (recentf-max-saved-items 3000)
  (register-preview-delay 0)
  (register-preview-function #'consult-register-format)
  (xref-show-xrefs-function #'consult-xref)
  (xref-show-definitions-function #'consult-xref)
  (recentf-max-menu-items 3000)
  (consult-narrow-key "<") ;; (kbd "C-SPC")
  :init
  (recentf-mode 1)


  :config
  (consult-customize
   consult-git-grep consult-grep consult-ripgrep
   consult-bookmark consult-recent-file consult-xref consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   :preview-key (list :debounce 0.2 "C-SPC"))

  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (car (project-roots project))))))
#+END_SRC
*** COMMENT Consult gh
#+BEGIN_SRC emacs-lisp
(use-package consult-gh
  :defer t
  :config
  (require 'consult-gh-transient)
  (consult-gh-forge-mode +1))
#+END_SRC

**** Consult gh embark
#+BEGIN_SRC emacs-lisp
(use-package consult-gh-embark
  :after consult-gh
  :config
  (consult-gh-embark-mode +1))
#+END_SRC

** Corfu
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package corfu
  ;; :ensure (:host github :repo "minad/corfu" :ref "6b1ceef882e9809083e660c10d669d132746b975")
  :defer 2
  :custom
  (corfu-auto t)
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-commit-predicate nil)   ;; Do not commit selected candidates on next input
  (corfu-quit-at-boundary t)     ;; Automatically quit at word boundary
  (corfu-quit-no-match t)        ;; Automatically quit if there is no match
  (corfu-auto-delay 0.1)
  (corfu-echo-documentation t) ;; Do not show documentation in the echo area
  (corfu-preselect-first nil)
  (corfu-auto-prefix 2)
  (corfu-separator ?\s)
  :bind
  (("C-x C-o" . completion-at-point)
   ("C-SPC" . completion-at-point)
   :map corfu-map
   ("TAB" . corfu-next)
   ([tab] . corfu-next)
   ("C-j" . corfu-next)
   ("C-k" . corfu-previous)
   ("S-TAB" . corfu-previous)
   ("<return>" . corfu-insert)
   ("RET" . corfu-insert)
   ("C-<return>" . corfu-insert-seporator)
   ([backtab] . corfu-previous))
  :config
  (add-hook 'meow-insert-exit-hook (lambda () (corfu-quit)))
  (setq lsp-completion-provider :none)

  (global-corfu-mode))
#+END_SRC
*** Corfu history
#+BEGIN_SRC emacs-lisp
(use-package corfu-history
  :ensure (corfu-history :host github :repo "minad/corfu" :files ("extensions/corfu-history.el"))
  :after corfu
  :config
  (with-eval-after-load 'safehist
    (cl-pushnew 'corfu-history savehist-additional-variables))
   (setq corfu-sort-override-function 'corfu-history--sort)

  (corfu-history-mode))
#+END_SRC
*** Corfu popup doc
#+BEGIN_SRC emacs-lisp
(use-package corfu-popupinfo
  :ensure (corfu-popupinfo :host github :repo "minad/corfu" :files ("extensions/corfu-popupinfo.el"))
  :bind (:map corfu-map
              ("C-m" . corfu-popupinfo-documentation))
  :custom
  (corfu-echo-delay nil)
  (corfu-popupinfo-delay '(0.5 . 0.5))
  :after corfu
  :config
  (corfu-popupinfo-mode))
#+END_SRC

*** Pretty icon
#+BEGIN_SRC emacs-lisp
  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

#+END_SRC

*** Cape
#+BEGIN_SRC emacs-lisp
(use-package cape
  :bind ("C-c C-e" . cape-prefix-map) ;; Alternative keys: M-p, M-+, ...
  :init
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+END_SRC

** Completion icons
#+BEGIN_SRC emacs-lisp
(use-package nerd-icons-completion
  :after marginalia
  :hook (marginalia-mode . nerd-icons-completion-mode))
#+END_SRC

* Programming
** Lsp manager
#+BEGIN_SRC emacs-lisp :results silent
(use-package mason
  :defer t
  :config
  (mason-ensure))
#+END_SRC
** COMMENT LSP mode
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :hook
  ((clojure-mode
    scss-mode
    go-ts-mode
    css-mode
    js-mode
    typescript-mode
    vue-mode
    vue-ts-mode
    web-mode
    html-mode
    ng2-ts-mode
    python-mode
    dart-mode
    typescript-tsx-mode

    html-ts-mode
    c-sharp-ts-mode
    typescript-ts-mode
    go-ts-mode
    js-ts-mode
    bash-ts-mode
    tsx-ts-mode) . lsp-deferred)
  :bind
  (("C-c f n" . flycheck-next-error)
   ("C-c l a" . lsp-execute-code-action)
   ("C-c i m" . lsp-ui-imenu)
   ("C-c l d" . lsp-workspace-folders-remove)
   ("C-c l t" . lsp-find-type-definition)
   ("C-c l f" . lsp-find-references)
   ("C-c l i" . lsp-find-implementation)
   ("C-c l w" . lsp-workspace-restart)
   ("C-c r l" . lsp)
   ("C-c l r" . lsp-rename)
   :map meow-normal-state-keymap
   ("gt" . lsp-goto-type-definition)
   ("gi" . lsp-goto-implementation)
   ("\\l" . lsp-execute-code-action))
  :bind-keymap
  ("s-9" . lsp-command-map)
  :init
  (setq lsp-keymap-prefix "s-9")
  (setq lsp-volar-take-over-mode nil)
  (setq lsp-headerline-breadcrumb-enable nil)
  :custom
  (lsp-rust-analyzer-server-display-inlay-hints nil)
  (lsp-log-io nil)
  (lsp-idle-delay 0.3)
  (lsp-auto-guess-root t)
  (lsp-completion-provider :capf)
  (lsp-enable-on-type-formatting nil)
  (lsp-eldoc-render-all nil)
  (lsp-prefer-flymake nil)
  (lsp-modeline-diagnostics-scope :workspace)
  (lsp-enable-indentation nil)
  (lsp-apply-edits-after-file-operations nil)
  (lsp-clients-typescript-server-args '("--stdio"))
  (lsp-completion-default-behaviour :insert)
  (lsp-yaml-schemas '((kubernetes . ["/auth-reader.yaml", "/deployment.yaml"])))
  (lsp-disabled-clients '(html-ls vls vue-semantic-server))
  (lsp-signature-render-documentation nil)
  (lsp-signature-auto-activate nil)
  (lsp-enable-snippet nil)
  (lsp-use-plists t)
  (lsp-enable-file-watchers t)
  (lsp-file-watch-threshold 8000)
  (lsp-modeline-code-actions-mode nil)
  (lsp-modeline-code-actions-enable nil)
  (lsp-modeline-workspace-status-enable nil)
  (lsp-modeline-code-action-icons-enable nil)
  (lsp-modeline-diagnostics-mode nil)
  (lsp-modeline-diagnostics-enable nil)
  :config
  ;; (setq lsp-csharp-server-path (expand-file-name "~/.dotnet/tools/csharp-ls"))
  ;; (setq lsp-csharp-ls-executable (expand-file-name "~/.dotnet/tools/csharp-ls"))
  ;; (setq lsp-csharp-server-type 'csharp-ls)
   ;; (setenv "DOTNET_ROOT" "/usr/local/share/dotnet")
   ;; (setenv "DOTNET_ROLL_FORWARD" "Major")

  ;; (setq lsp-pyright-venv-path (concat (getenv "HOME") "/.virtualenvs"))
  ;; (setq lsp-pyright-venv-path "./venv")
  (setq lsp-clients-angular-language-server-command
        '("node" "./node_modules/@angular/language-server/index.js"
          "--stdio"
          "--tsProbeLocations" "."
          "--ngProbeLocations" "."))
  (define-key lsp-mode-map (kbd "s-9") lsp-command-map)
  (setq lsp-auto-execute-action nil)
  (setq lsp-javascript-display-return-type-hints t)
  (setq lsp-json-schemas
        `[
          (:fileMatch ["ng-openapi-gen.json"] :url "https://raw.githubusercontent.com/cyclosproject/ng-openapi-gen/master/ng-openapi-gen-schema.json")
          (:fileMatch ["package.json"] :url "https://raw.githubusercontent.com/SchemaStore/schemastore/master/src/schemas/json/package.json")
          (:fileMatch ["opencode.json"] :url "https://opencode.ai/config.json")
          ])
  (set-face-attribute 'lsp-face-highlight-read nil :foreground "#61AFEF" :bold t :underline nil)
  ;; Eslint
  (setq lsp-eslint-download-url "https://marketplace.visualstudio.com/_apis/public/gallery/publishers/dbaeumer/vsextensions/vscode-eslint/3.0.10/vspackage") ;; latest VSCode eslint extension from marketplace
  (setq lsp-eslint-server-command `("node"
                                    "/Users/darkawower/.vscode/extensions/dbaeumer.vscode-eslint-3.0.10/server/out/eslintServer.js"
                                    "--stdio"))
  (setq lsp-enable-symbol-highlighting t
        lsp-enable-snippet nil
        lsp-pyls-plugins-flake8-enabled nil)
  (set-face-foreground 'lsp-face-highlight-read "#61AFEF")
  (set-face-foreground 'lsp-face-highlight-textual "#61AFEF")

  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.bun\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.npm\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.act\\'")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.pnpm-store\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\venv\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\pyenv\\'")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.cache\\'")
  (set-face-attribute 'lsp-face-highlight-textual nil :background "#c0caf5")
  (set-face-attribute 'lsp-flycheck-info-unnecessary-face nil :inherit 'shadow :foreground nil)
  (my/setup-compilation-errors)
  (setq lsp-volar-hybrid-mode nil)

  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-stdio-connection '("vtsls" "--stdio"))
    :activation-fn (lsp-activate-on "typescript" "javascript" "typescriptreact" "javascriptreact")
    :priority 1
    :server-id 'vtsls
    :multi-root t
    :initialization-options (lambda ()
                              (list :typescript (list :tsdk "/path/to/typescript/lib"))))))

#+END_SRC

*** Lsp optimisation. Lsp booster.
See [[https://github.com/blahgeek/emacs-lsp-booster][detail]]
#+BEGIN_SRC emacs-lisp
(defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+END_SRC

*** Tailwind css
#+BEGIN_SRC emacs-lisp
(use-package lsp-tailwindcss
  :defer t
  :init
  (setq lsp-tailwindcss-add-on-mode t)
  :config
  (add-hook 'before-save-hook 'lsp-tailwindcss-rustywind-before-save))
#+END_SRC

*** LSP. Pyright
#+BEGIN_SRC emacs-lisp
(use-package lsp-pyright
  :defer t
  :hook (python-ts-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp-deferred)))
  :config
  (setq lsp-pyright-auto-import-completions t)
  (setq lsp-pyright-auto-search-paths t)
  (setq lsp-pyright-log-level "trace")
  (setq lsp-pyright-multi-root nil)
  (setq lsp-pyright-use-library-code-for-types t)
  (setq lsp-pyright-diagnostic-mode "workspace"))
#+END_SRC

*** YAML
**** YAML PRO
#+BEGIN_SRC emacs-lisp
(use-package yaml-pro
  :defer t
  :hook (yaml-ts-mode . yaml-pro-mode))
#+END_SRC

*** LSP UI
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :ensure (:host github :repo "emacs-lsp/lsp-ui")
  :after lsp-mode
  :bind (:map meow-normal-state-keymap
         ("\\h" . lsp-ui-doc-toggle)
         :map lsp-ui-peek-mode-map
         ("C-j" . lsp-ui-peek--select-next)
         ("C-k" . lsp-ui-peek--select-prev))
  :config
  (setq lsp-ui-sideline-diagnostic-max-line-length 100
        lsp-ui-sideline-diagnostic-max-lines 8
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-doc-delay 1
        lsp-ui-doc-position 'top
        lsp-ui-doc-show-with-mouse nil))
#+END_SRC

*** Flutter (dart)
#+BEGIN_SRC emacs-lisp
  (use-package lsp-dart
    :defer t
    :hook (dart-mode . (lambda () (interactive)
                         (add-hook 'after-save-hook
                                   (lambda ()
                                     ;; (flutter-run-or-hot-reload)
                                     (flutter-hot-restart)
                                     )
                                   t t)))
    :custom
    (lsp-dart-dap-flutter-hot-reload-on-save t)
    :config
    (defun lsp-dart-flutter-widget-guide--add-overlay-to (buffer line col string)
      "Add to BUFFER at LINE and COL a STRING overlay."
      (save-excursion
        (goto-char (point-min))
        (forward-line line)
        (move-to-column col)
        (when (string= lsp-dart-flutter-widget-guide-space (string (following-char)))
          (let ((ov (make-overlay (point) (1+ (point)) buffer)))
            (overlay-put ov 'category 'lsp-dart-flutter-widget-guide)
            (overlay-put ov 'display (propertize string
                                                 'face 'custom-comment-tag)))))))
#+END_SRC

*** LSP java
#+BEGIN_SRC emacs-lisp
(use-package lsp-java
  :hook (java-mode . lsp-deferred))
#+END_SRC

*** Eslint, install once
Installation instructions:
#+BEGIN_SRC emacs-lisp  :tangle no
(url-copy-file (lsp-vscode-extension-url "dbaeumer" "vscode-eslint" "3.0.16") "~/tmp/foo.zip")
(lsp-unzip "~/tmp/foo.zip" lsp-eslint-unzipped-path)
#+END_SRC

*** COMMENT Biome lsp
#+BEGIN_SRC emacs-lisp :results silent
(use-package lsp-biome
  :ensure (:host github :repo "cxa/lsp-biome")
  :preface
  (defun my/lsp-biome-active-hook ()
    (setq-local apheleia-formatter '(biome)))
  :config
  (add-hook 'lsp-biome-active-hook #'my/lsp-biome-active-hook))
#+END_SRC
** COMMENT Flycheck
*** Core package
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :bind (("C-j" . flycheck-next-error)
         ("C-k" . flycheck-previous-error)
         ("C-c f ]" . flycheck-next-error)
         ("C-c f [" . flycheck-previous-error)
         ("C-c l e" . flycheck-list-errors)
         ("C-c e c" . flycheck-copy-errors-as-kill)
         ("C-c e C" . my/flycheck-copy-errors-buffer)
         ("C-c f e" . flycheck-list-errors))
  :init
  (global-flycheck-mode)
  :custom
  ;; Sometimes the macos emacs version is very laggy with fringes ;C
  (flycheck-indication-mode nil)
  (flycheck-display-errors-delay 0)
  (flycheck-mode-line nil)
  (flycheck-check-syntax-automatically '(save idle-change new-line mode-enabled))
  (flycheck-checker-error-threshold 120)
  (flycheck-highlighting-mode 'columns)
  (flycheck-idle-change-delay 0.3)
  :config
  (global-flycheck-mode)
  (add-to-list 'flycheck-disabled-checkers 'javascript-eslint)
  ;; use eslint with web-mode for jsx files
  ;; (flycheck-add-mode 'javascript-eslint 'web-mode)
  ;; Workaround for eslint loading slow
  ;; https://github.com/flycheck/flycheck/issues/1129#issuecomment-319600923
  (advice-add 'flycheck-eslint-config-exists-p :override (lambda() t)))

;; (with-eval-after-load 'flycheck
;;   (flycheck-define-checker stylelint
;;     "A SCSS/CSS linter using stylelint."
;;     :command ("stylelint" "--formatter" "compact" "--stdin-filename" source-original)
;;     :standard-input t
;;     :error-patterns
;;     ((error line-start (file-name) ": line " line ", col " column ", " (message) line-end))
;;     :modes (scss-mode css-mode less-css-mode))

;;   (add-to-list 'flycheck-checkers 'stylelint)
;;   (flycheck-add-next-checker 'lsp 'stylelint))

;; (add-hook 'scss-mode-hook
;;           (lambda ()
;;             (flycheck-select-checker 'stylelint)
;;             (flycheck-mode)))

;; (with-eval-after-load 'flycheck
;;   (flycheck-add-next-checker 'lsp 'stylelint)))
#+END_SRC
**** Flycheck functions
#+BEGIN_SRC emacs-lisp :results silent
(defun my/flycheck-copy-errors-buffer ()
    "Open flycheck errors buffer, copy all contents, and close window."
    (interactive)
    (let ((original-window (selected-window)))
      ;; Always open flycheck errors buffer first
      (flycheck-list-errors)
      ;; Check if the errors buffer exists and has content
      (let ((flycheck-buffer (get-buffer "*Flycheck errors*")))
        (if (and flycheck-buffer (get-buffer-window "*Flycheck errors*"))
            (progn
              ;; Switch to errors buffer
              (select-window (get-buffer-window "*Flycheck errors*"))
              ;; Copy all buffer contents
              (mark-whole-buffer)
              (copy-region-as-kill (point-min) (point-max))
              ;; Close the window
              (quit-window)
              ;; Return to original window
              (select-window original-window)
              (message "Flycheck errors copied to kill ring"))
          (progn
            ;; If buffer still doesn't exist or has no window, return to original
            (select-window original-window)
            (message "No flycheck errors found"))))))
#+END_SRC
*** COMMENT Beatiful flycheck, flyover
https://github.com/konrad1977/flyover
#+BEGIN_SRC emacs-lisp :results silent
(use-package flyover
  :hook ((flycheck-mode . flyover-mode)
         (flymake-mode . flyover-mode))
  :custom
  ;; Checker settings
  (flyover-checkers '(flycheck flymake))
  (flyover-levels '(error warning info))

  ;; Appearance
  (flyover-use-theme-colors t)
  (flyover-background-lightness 45)
  (flyover-percent-darker 40)
  (flyover-text-tint 'lighter)
  (flyover-text-tint-percent 50)

  ;; Icons
  (flyover-info-icon " ")
  (flyover-warning-icon " ")
  (flyover-error-icon " ")

  ;; Border styles: none, pill, arrow, slant, slant-inv, flames, pixels
  (flyover-border-style 'none)
  (flyover-border-match-icon t)

  ;; Display settings
  (flyover-hide-checker-name t)
  (flyover-show-virtual-line t)
  (flyover-virtual-line-type 'curved-dotted-arrow)
  (flyover-line-position-offset 1)

  ;; Message wrapping
  (flyover-wrap-messages t)
  (flyover-max-line-length 80)

  ;; Performance
  (flyover-debounce-interval 0.2)
  (flyover-cursor-debounce-interval 0.3)

  ;; Icon

  (flyover-info-icon "ðŸ›ˆ")
  (flyover-warning-icon "âš ")
  (flyover-error-icon "âœ˜")

  ;; Display mode (controls cursor-based visibility)
  (flyover-display-mode 'show-only-on-same-line))
#+End_Src
*** COMMENT Consult flycheck
#+BEGIN_SRC emacs-lisp
(use-package consult-flycheck
  :after consult)
#+END_SRC
*** COMMENT Flyckec posframe
#+BEGIN_SRC emacs-lisp :results silent
(use-package flycheck-posframe
  :after flycheck
  :hook (flycheck-mode . flycheck-posframe-mode)
  :custom
  (flycheck-posframe-position 'window-bottom-right-corner)
  :config
  (set-face-attribute 'flycheck-posframe-error-face nil :inherit 'error)
  (setq flycheck-posframe-warning-prefix "\u26a0 "))
#+END_SRC

** Lsp (Eglot)
*** Rassumfrassum - LSP multiplexer
[[https://github.com/joaotavora/rassumfrassum][rassumfrassum]] connects multiple LSP servers to one client.

#+BEGIN_SRC shell :tangle no
pip install rassumfrassum
npm install -g typescript-language-server vscode-langservers-extracted
#+END_SRC

**** Angular/TypeScript preset
Create =~/.config/rassumfrassum/angular.py=:
#+BEGIN_SRC python :tangle ~/.config/rassumfrassum/angular.py
"""Angular/TypeScript preset: typescript-language-server + eslint."""


def servers():
    return [
        ["typescript-language-server", "--stdio"],
        ["ngserver", "--stdio", "--tsProbeLocations", ".", "--ngProbeLocations", "."],
        [
            "node",
            "/Users/darkawower/.emacs.d/var/lsp/server/eslint/unzipped/extension/server/out/eslintServer.js",
            "--stdio",
        ],
    ]
#+END_SRC

**** Python preset
#+BEGIN_SRC python :tangle ~/.config/rassumfrassum/angular.py
"""Python preset: pyright + ty"""

def servers():
    return [
        ['basedpyright-langserver', '--stdio'],
        ['ty', '--server'],
    ]
#+END_SRC

*** Eglot booster
#+BEGIN_SRC emacs-lisp :results silent
(use-package eglot-booster
	:ensure ( eglot-booster :type git :host nil :repo "https://github.com/jdtsmith/eglot-booster")
	:after eglot
	:config (eglot-booster-mode))
#+END_SRC
*** COMMENT Eglot flycheck
#+BEGIN_SRC emacs-lisp :results silent
(use-package flycheck-eglot
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
#+END_SRC

**** COMMENT Flycheck sidelined
#+BEGIN_SRC emacs-lisp :results silent
(use-package sideline
  ;; :hook (flycheck-mode . sideline-mode)
  :init
  (setq flycheck-display-errors-function nil)
  (setq sideline-backends-right '(sideline-flycheck)))

(use-package sideline-flycheck :hook (flycheck-mode . sideline-flycheck-setup))
#+END_SRC
*** Eglot, core package
#+BEGIN_SRC emacs-lisp
(use-package eglot
  :ensure nil
  :defer t
  :bind (("C-c g i" . eglot-find-implementation)
         ("C-c l r" . eglot-rename)
         ("C-c r l" . eglot)
         ("C-c l d" . eglot-find-typeDefinition)
         ("C-c l f" . xref-find-references)
         :map meow-normal-state-keymap
         ("g i" . eglot-find-implementation)
         ("g r" . xref-find-references)
         ("\\i" . my/eglot-toggle-inlay-hints)
         ("\\l" . eglot-code-actions))
  :hook
  ((typescript-ts-mode
    tsx-ts-mode
    js-ts-mode
    html-ts-mode
    ng2-ts-mode
    rust-ts-mode
    python-ts-mode
    go-ts-mode
    vue-ts-mode) . eglot-ensure)
  ;; (eglot-managed-mode-hook . (lambda () (eglot-semantic-tokens-mode -1)))
  :custom
  (eglot-semantic-token-modifiers nil)
  (eglot-semantic-token-types nil)
  (eglot-confirm-server-initiated-edits nil)
  (eglot-code-action-indicator "ï„©")
  (eglot-events-buffer-config '(:size 0 :format nil))
  :config

  (defun my/eglot-disable-inline-hints ()
    "Disable inline hints in eglot."
    (when (bound-and-true-p eglot-inlay-hints-mode)
      (eglot-inlay-hints-mode -1)))

  (add-hook 'eglot-managed-mode-hook #'my/eglot-disable-inline-hints)
  (add-to-list 'eglot-server-programs
               '((typescript-ts-mode tsx-ts-mode js-ts-mode ng2-ts-mode)
                 . ("typescript-language-server" "--stdio")))

  ;; https://github.com/joaotavora/eglot/discussions/1184
  (defun my/vue-eglot-init-options ()
    (let* ((root (when (project-current) (project-root (project-current))))
           (local (when root (expand-file-name "node_modules/typescript/lib" root)))
           (global (expand-file-name "~/.volta/tools/image/packages/typescript/lib/node_modules/typescript/lib"))
           (tsdk (if (and local (file-exists-p (expand-file-name "typescript.js" local))) local global)))
      `(:typescript (:tsdk ,tsdk) :vue (:hybridMode :json-false))))

  (add-to-list 'eglot-server-programs
               `(vue-ts-mode . ("vue-language-server" "--stdio"
                                :initializationOptions ,(my/vue-eglot-init-options))))

  ;; Python via rassumfrassum
  (add-to-list 'eglot-server-programs
               '(python-ts-mode . ("rass" "python")))

  (add-to-list 'eglot-server-programs
               '(html-ts-mode . ("rass" "angular-html")))

  ;; (add-to-list 'eglot-server-programs
  ;;              `(vue-ts-mode . ("rass" "vue-lint")))


  ;; Go (single server, no rass needed)
  (add-to-list 'eglot-server-programs
               '(go-ts-mode . ("gopls")))

  ;; (add-to-list 'eglot-server-programs '((typescript-mode typescript-ts-mode) . ("rass" "angular")))
  (defun my/typescript-lsp-server (&optional _interactive _project)
    "Return LSP server command based on whether project is Angular or not."
    (let* ((project-root (locate-dominating-file default-directory "angular.json"))
           (angular-p (and project-root
                           (file-exists-p (expand-file-name "angular.json" project-root)))))
(message "IS ANGULAR? %s" angular-p)
      (if angular-p
          ;; Angular project - include ngserver
          '("rass" "angular")
          ;; '("lspx"
          ;;   "--lsp" "typescript-language-server --stdio"
          ;;   "--lsp" "ngserver --stdio --tsProbeLocations . --ngProbeLocations .")
            ;; "--lsp" "node /Users/darkawower/.emacs.d/var/lsp/server/eslint/unzipped/extension/server/out/eslintServer.js --stdio")
            '("rass" "vue"))))

  (add-to-list 'eglot-server-programs
               '((typescript-mode typescript-ts-mode tsx-ts-mode js-mode js-ts-mode) . my/typescript-lsp-server))


  ;; Rust
  (add-to-list 'eglot-server-programs
               '((rust-ts-mode rust-mode) . ("rust-analyzer"))))
#+END_SRC

*** Toggle eglot inline hints
#+BEGIN_SRC emacs-lisp :results silent
(defun my/eglot-toggle-inlay-hints ()
  "Toggle eglot inlay hints."
  (interactive)
  (if (fboundp 'eglot-inlay-hints-mode)
      (eglot-inlay-hints-mode (if eglot-inlay-hints-mode -1 1))
    (user-error "Eglot is not loaded")))
#+END_SRC

** Flymake
*** Functions
**** Flymake, copy errors
#+BEGIN_SRC emacs-lisp
(defun my/flymake--format-diagnostic (diag)
  "Format a Flymake DIAG as \"LINE:COL [TYPE] MESSAGE\"."
  (let* ((beg  (flymake-diagnostic-beg diag))
         (line (line-number-at-pos beg))
         (col  (save-excursion (goto-char beg) (1+ (current-column))))
         (typ  (flymake-diagnostic-type diag))
         (msg  (flymake-diagnostic-text diag)))
    (format "%d:%d [%s] %s" line col typ msg)))

(defun my/flymake-kill-error ()
  "Copy the Flymake diagnostic at point to the kill ring, prefixed by project-relative file path."
  (interactive)
  (let* ((diags (flymake-diagnostics (point) (min (1+ (point)) (point-max)))))
    (if (null diags)
        (user-error "No Flymake diagnostic at point")
      (let* ((diag (car diags))
             (text (my/flymake--format-diagnostic diag))
             (header (my/project-relative-path)))
        (kill-new (format "%s\n%s" header text))
        (message "Copied: %s â€” %s" header text)))))

(defun my/flymake-kill-errors ()
  "Copy all Flymake diagnostics in the buffer to the kill ring, prefixed by project-relative file path."
  (interactive)
  (let* ((diags (flymake-diagnostics)))
    (if (null diags)
        (user-error "No Flymake diagnostics in this buffer")
      (let* ((lines (mapcar #'my/flymake--format-diagnostic diags))
             (header (my/project-relative-path))
             (blob  (concat header "\n" (string-join lines "\n"))))
        (kill-new blob)
        (message "Copied %d Flymake diagnostics from %s" (length diags) header)))))
#+END_SRC

*** Core Package
#+BEGIN_SRC emacs-lisp
(use-package flymake
  :ensure nil
  :bind
  (("C-j" . flymake-goto-next-error)
   ("C-k" . flymake-goto-prev-error)
   ("C-c e l" . flymake-show-diagnostics-buffer)
   ("C-c l e" . flymake-show-diagnostics-buffer)
   ("C-c e c" . my/flymake-kill-error)
   ("C-c e C" . my/flymake-kill-errors))
  :hook
  (prog-mode . flymake-mode)
  (flymake-diagnostics-buffer-mode . meow-normal-mode)
  :custom
  (flymake-no-changes-timeout 0.6)
  (flymake-start-on-flymake-mode t)
  (flymake-start-on-save-buffer t)
  (flymake-start-on-newline t)
  :config
  (setq lsp-diagnostics-provider :flymake)
  ;; (setq flymake-show-diagnostics-at-end-of-line nil)

  ;; <<lsp-flymake-patch>>
  (defun my/inhibit-message-advice (orig-fn &rest args)
    "Prevent display messag en the echo area!"
    (let ((inhibit-message t))
      (apply orig-fn args)))
  
  (advice-add 'flymake-goto-next-error :around #'my/inhibit-message-advice)
  (advice-add 'flymake-goto-prev-error :around #'my/inhibit-message-advice))
#+END_SRC
*** COMMENT Flymake sideline UI
#+BEGIN_SRC emacs-lisp :results silent
(use-package sideline-flymake
  :hook (flymake-mode . sideline-mode)
  :init
  (setq sideline-flymake-display-mode 'point
        sideline-backends-right '(sideline-flymake))
  :config
  (setq sideline-delay 0.5)
  (setq sideline-inhibit-display-function
        (lambda ()
          (or (minibufferp)
              (region-active-p)))))
#+END_SRC

*** Flymake posframe
#+BEGIN_SRC emacs-lisp :results silent
(use-package flymake-posframe
  :ensure (flymake-posframe :host github :repo "Ladicle/flymake-posframe")
  :hook ((flymake-mode . flymake-posframe-mode)
         (meow-normal-mode . my/toggle-flymake-posframe)
         (meow-insert-mode . my/toggle-flymake-posframe))
  :config
  (get-buffer-create flymake-posframe-buffer)

  (defalias 'flymake--diag-text #'flymake-diagnostic-text))
#+END_SRC

**** The function to toggle the posframe mode by current meow state
#+BEGIN_SRC emacs-lisp :results silent
(defun my/toggle-flymake-posframe ()
  "Toggle the flymake posframe mode by current meow state"

  (if (meow-normal-mode-p) 
      (flymake-posframe-mode 1)
    (flymake-posframe-mode -1)))
#+END_SRC
*** Flymake, eslint
ESLint via flymake-eslint (separate from LSP, since vscode-eslint-language-server uses pull diagnostics which Eglot doesn't support)
#+BEGIN_SRC emacs-lisp
(use-package flymake-jsts
  :ensure '(flymake-jsts :type git :host github :repo "orzechowskid/flymake-jsts" :branch "main")
  :hook (eglot-managed-mode . flymake-jsts-eslint-enable)
  :config
  (setq flymake-eslint-executable-args nil))
#+END_SRC

*** Flymake, stylelint
#+BEGIN_SRC emacs-lisp
(use-package flymake-stylelint
  :ensure (flymake-stylelint
             :type git
             :host github
             :repo "orzechowskid/flymake-stylelint")
  :hook ((css-mode . flymake-stylelint-enable)
         (scss-mode . flymake-stylelint-enable)
         (less-mode . flymake-stylelint-enable)
         (web-mode . flymake-stylelint-enable))
  :config
  (setq flymake-stylelint-executable "stylelint"))
#+END_SRC
** Eldoc
*** Toggle eldoc buffer
#+BEGIN_SRC emacs-lisp :results silent
(defun my/toggle-eldoc-buffer ()
  "Toggle Eldoc documentation buffer."
  (interactive)
  (let ((buf (get-buffer "*eldoc*")))
    (if (and buf (get-buffer-window buf))
        (delete-windows-on buf)
      (eldoc-doc-buffer t))))
#+END_SRC
*** Main package
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :after meow
  :custom
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-display-truncation-message nil)
  (eldoc-idle-delay 0.7)
  :config
  ;; (setq-default eldoc-display-functions '(eldoc-display-in-buffer))
  ;; (advice-add 'eldoc-display-in-echo-area :override #'ignore)
  (add-to-list
   'display-buffer-alist
   '("*eldoc*"
     (my/display-buffer-right-smart)
     (select . nil)
     (window-width . 0.4)))
  (global-eldoc-mode))
#+END_SRC
*** Better eldoc UI
#+BEGIN_SRC emacs-lisp :results silent
(use-package eldoc-box
  :bind (:map meow-normal-state-keymap
              ("\\b" . my/toggle-eldoc-buffer)
              ("\\h" . eldoc-box-help-at-point))
  :custom-face
  (eldoc-box-border ((t (:background unspecified :inherit default))))
  :config
  (setf (alist-get 'internal-border-width eldoc-box-frame-parameters) 15)
  (setf (alist-get 'left-fringe eldoc-box-frame-parameters) 10)
  (setf (alist-get 'right-fringe eldoc-box-frame-parameters) 10)
  (add-hook 'eldoc-box-buffer-setup-hook #'eldoc-box-prettify-ts-errors 0 t))
#+END_SRC

** Compilation
*** Functions
**** Compilation per project
#+BEGIN_SRC emacs-lisp :results silent
(defun my/compilation-buffer-name-by-project (_mode)
  (let* ((pr (project-current nil))
         (name (if pr
                   (file-name-nondirectory
                    (directory-file-name (project-root pr)))
                 (abbreviate-file-name default-directory))))
    (format "*compilation:%s*" name)))

#+END_SRC
**** Run vitest
#+BEGIN_SRC emacs-lisp
(defun my/run-vitest-from-current-buffer ()
  "Run vitest for the current buffer's file."
  (interactive)
  (let* ((file (file-info--get-project-related-path)))
    (if file
        (compile (format "bun run test %s" (shell-quote-argument file)))
      (message "Buffer is not visiting a file."))))
#+END_SRC
**** Find filename for eslint error
#+BEGIN_SRC emacs-lisp
(defun compile-eslint--find-filename ()
  "Find the filename for current error."
  (save-match-data
    (save-excursion
      (when (re-search-backward (rx bol (group "/" (+ any)) eol))
        (list (match-string 1))))))
#+END_SRC

**** Show compilation buffer
#+BEGIN_SRC emacs-lisp :results silent
(defun my/show-compilation-buffer ()
  "Display *compilation* buffer."
  (interactive)
  (let* ((pr (project-current nil))
         (name (if pr
                   (file-name-nondirectory
                    (directory-file-name (project-root pr)))
                 (abbreviate-file-name default-directory)))
         (bufname (format "*compilation:%s*" name)))
    (if-let ((buf (get-buffer bufname)))
        (pop-to-buffer buf)
      (message "No compilation buffer for this project"))))
#+END_SRC

*** Buffer position
Compilation always at right
#+BEGIN_SRC emacs-lisp
(defun my/get-rightmost-window ()
  "Get the rightmost window on the current frame."
  (let ((windows (window-list)))
    (car (sort windows (lambda (a b)
                        (> (nth 0 (window-edges a))
                           (nth 0 (window-edges b))))))))

(defun my/display-compilation-buffer (buffer alist)
  "Custom display function for compilation buffer.
   If there are two windows, reuse the rightmost one.
   If there's only one window, split and use the right window."
  (let ((windows (window-list)))
    (cond
     ;; If we have exactly two windows
     ((= (length windows) 2)
      (set-window-buffer (my/get-rightmost-window) buffer)
      (my/get-rightmost-window))
     ;; If we have one window
     (t
      (let ((new-window (split-window-right)))
        (set-window-buffer new-window buffer)
        new-window)))))

(add-to-list 'display-buffer-alist
             `("^\\*compilation.*\\*$"
               (display-buffer-reuse-window my/display-compilation-buffer)
               (reusable-frames . visible)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/get-visible-buffers-cnt ()
  "Get the number of visible buffers"
  (let ((visible-buffers 0)
        (buffer-list (buffer-list)))
    (dolist (buffer buffer-list)
      (if (get-buffer-window buffer)
          (cl-incf visible-buffers)))
    visible-buffers))

(defun my/display-buffer-other-vertical (buffer &optional alist)
  "Display BUFFER in another window. If only one window, split vertical before."
  (if (one-window-p)
      (split-window-horizontally))
  (display-buffer-use-some-window buffer alist))

(add-to-list 'display-buffer-alist
             '(("\\*Messages\\*"
                (display-buffer-in-side-window display-buffer-reuse-window)
                (side . right)
                (slot . 0)
                (window-width . 0.4)
                (window-parameters . ((no-delete-other-windows . t))))))

#+END_SRC

*** Setup compilation errors
#+BEGIN_SRC emacs-lisp
(defun my/setup-compilation-errors ()
  (interactive)
  (setq compilation-scroll-output t)
  (setq compilation-error-regexp-alist '())
  (setq compilation-error-regexp-alist-alist '())


  ;; eslint https://github.com/Fuco1/compile-eslint/blob/master/compile-eslint.el
  (when (not compilation-error-regexp-alist-alist)
    (setq compilation-error-regexp-alist-alist '()))

  (let ((form `(eslint
                ,(rx-to-string
                  '(and (group (group (+ digit)) ":" (group (+ digit)))
                        (+ " ") (or "error" "warning")))
                compile-eslint--find-filename
                2 3 2 1)))

    (if (assq 'eslint compilation-error-regexp-alist-alist)
        (setf (cdr (assq 'eslint compilation-error-regexp-alist-alist)) (cdr form))
      (push form compilation-error-regexp-alist-alist)))
  (push 'eslint compilation-error-regexp-alist)



  (add-to-list 'compilation-error-regexp-alist '("^[[:blank:]]*\\([/_-\\.[:alnum:]]+\\):\\([[:digit:]]+\\):\\([[:digit:]]+\\) - error.*$" 1 2 3))
  ;; React
  (add-to-list 'compilation-error-regexp-alist '("[[:blank:]]*\\([/_\\.[:alnum:]-]+\\):\\([[:digit:]]+\\):\\([[:digit:]]+\\) - error.*$" 1 2 3))
  ;; Angular
  (add-to-list 'compilation-error-regexp-alist '("^Error: \\([_[:alnum:]-/.]*\\):\\([0-9]+\\):\\([0-9]+\\)$" 1 2 3))
  ;; Angular vite
  (add-to-list 'compilation-error-regexp-alist '("\\([_[:alnum:]-/.]*\\):\\([0-9]+\\):\\([0-9]+\\)" 1 2 3))

  ;; Tests
  (add-to-list 'compilation-error-regexp-alist
             '("^Error:[[:blank:]]*\\([[:alnum:]_./-]+\\):\\([[:digit:]]+\\):\\([[:digit:]]+\\)" 1 2 3))

  (add-to-list 'compilation-error-regexp-alist '("\\([_[:alnum:]-/.]*\\)(\\([0-9]+\\),\\([0-9]+\\))" 1 2 3))

  (add-to-list 'compilation-error-regexp-alist '("FILE[[:blank:]]*\\([_[:alnum:]-/.]*\\):\\([0-9]+\\):\\([0-9]+\\)" 1 2 3))


  ;; Flutter
  (add-to-list 'compilation-error-regexp-alist 'dart-analyze)
  (add-to-list 'compilation-error-regexp-alist-alist '(dart-analyze "\\([^ ]*\\.dart\\):\\([0-9]+\\):\\([0-9]+\\)" 1 2 3)))
#+END_SRC

By default ~compile-goto-error~ open new window. It's redundant.
#+NAME: display-compilation-buffer
#+BEGIN_SRC emacs-lisp  :tangle no
(defun display-buffer-from-compilation-p (_buffer-name _action)
  (unless current-prefix-arg
    (with-current-buffer (window-buffer)
      (derived-mode-p 'compilation-mode))))

(push '(display-buffer-from-compilation-p
        display-buffer-use-least-recent-window
        (inhibit-same-window . nil))
      display-buffer-alist)
#+END_SRC
*** Core package
#+BEGIN_SRC emacs-lisp  :noweb yes
(use-package compile
  :defer t
  :ensure nil
  :bind
  (("C-c p c" . project-compile)
   ("C-c a r" . recompile)
   ("C-c C-c C-r" . recompile)
   ("C-c C-c r" . recompile)
   ("C-c C-v" . my/show-compilation-buffer)
   :map compilation-mode-map
   ("C-j" . compilation-next-error)
   ("C-k" . compilation-previous-error)
   :map compilation-minor-mode-map
   ("C-j" . compilation-next-error)
   ("C-k" . compilation-previous-error))
  :custom
  (compile-command "bun run build")
  :config
  (setq compilation-buffer-name-function #'my/compilation-buffer-name-by-project)
  <<display-compilation-buffer>>
  (my/setup-compilation-errors))
#+END_SRC

*** Fix compilation ansi colors
#+BEGIN_SRC emacs-lisp :results silent
(use-package ansi-color
  :ensure nil
  :config
  (defun colorize-compilation-buffer ()
    (ansi-color-apply-on-region compilation-filter-start (point-max)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
#+END_SRC
** Code quality
*** Codemetrics
#+BEGIN_SRC emacs-lisp
(use-package cognitive-complexity
  :defer t
  ;; :hook (prog-mode . cognitive-complexity-mode)
  :ensure (:host github :repo "abougouffa/cognitive-complexity")
  :config
  (cognitive-complexity-mode 1))
#+END_SRC
** Debugger DAPE
Clone this repo for js debug git@github.com:microsoft/vscode-js-debug.git
#+BEGIN_SRC emacs-lisp
(use-package dape
  :demand t
  :ensure (dape :type git :host github :repo "svaante/dape")
  :bind (("C-c d d" . dape)
         ("C-c d n" . dape-next)
         ("C-c d i" . dape-step-in)
         ("C-c d o" . dape-step-out)
         ("C-c d b" . dape-breakpoint-toggle)
         ("C-c d c" . dape-continue)
         ("C-c d q" . dape-disconnect-quit)
         ("C-c d r" . dape-restart)
         ("C-c d k" . dape-kill)
         ("C-c d X" . dape-remove-breakpoint-at-point)
         ("C-c d s" . dape-select-stack)
         ("C-c d t" . dape-select-thread)
         ("C-c d x" . dape-breakpoint-remove-all))
  :config
  (setq dape-buffer-window-arrangment 'right)
  (setq dape-inline-variables t))
#+END_SRC


* Programming languages
** Swift
#+BEGIN_SRC emacs-lisp :results silent
(use-package swift-ts-mode :defer t :mode ("\\.swift" . swift-ts-mode))
#+END_SRC
** Gleam
#+BEGIN_SRC emacs-lisp :results silent
(use-package gleam-ts-mode
  :defer 10
  :hook ((gleam-ts-mode . lsp-mode))
  :mode ("\\.gleam\\'" . gleam-ts-mode))
#+END_SRC
** Python
*** Repl
#+BEGIN_SRC emacs-lisp
(defun my/open-ipython-repl-here ()
  "Open IPython REPL in current buffer's directory."
  (interactive)
  (let ((default-directory (or (and (buffer-file-name)
                                    (file-name-directory (buffer-file-name)))
                               default-directory)))
    (run-python (python-shell-calculate-command) t t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure nil
  :defer t
  :bind (("C-c r p" . my/open-ipython-repl-here)
         :map inferior-python-mode-map
         ("C-k" . comint-previous-input)
         ("C-j" . comint-next-input))
  :custom
  (python-shell-interpreter "ipython")
  (python-shell-interpreter-args "-i --simple-prompt")
  (python-indent-level 4)
  :config
  (add-to-list 'display-buffer-alist '("^\\*Python\\*$" . (display-buffer-same-window))))
#+END_SRC

*** UV mode
**** Auto activation
#+BEGIN_SRC emacs-lisp :results silent
(use-package uv-mode 
  :defer t 
  :hook (pythons-ts-mode . uv-mode))
#+END_SRC
*** Virtualenv
#+BEGIN_SRC emacs-lisp :results silent
(use-package pyvenv :ensure t :hook (pythons-ts-mode . pyvenv-mode))
#+END_SRC

** Nix
#+BEGIN_SRC emacs-lisp
(use-package nix-mode :mode "\\.nix\\'")
#+END_SRC

** Emacs lisp
*** Main mode
#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :defer t
  :ensure nil
  :hook ((emacs-lisp-mode . (lambda () (setq fill-column 80))))
  :bind (("C-c o c" . outline-cycle)
         ("C-c o a" . outline-show-all)
         ("C-c o m" . outline-hide-body)
         ("C-c o ]" . outline-next-heading)
         ("C-c o [" . outline-previous-heading)
         ("C-c o e" . outline-hide-entry)
         ("C-c o n" . outline-toggle-children)
         ("C-c o b" . outline-cycle-buffer)
         ("C-c C-c e" . eval-buffer)))
#+END_SRC

*** Package development
#+BEGIN_SRC emacs-lisp
(use-package package-build :defer t)
(use-package package-lint :defer t)
#+END_SRC

*** Semantic highlight
#+BEGIN_SRC emacs-lisp
(use-package semel
  :ensure (semel :repo "eshelyaron/semel" :host github)
  :hook (emacs-lisp-mode . semel-mode))
#+END_SRC

*** COMMENT UI library :dev:
#+BEGIN_SRC emacs-lisp :results silent
(use-package vui
  :ensure (:host github :repo "d12frosted/vui.el"))
#+END_SRC
** Clojure
*** Main mode
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :defer t)
#+END_SRC
*** Repl
#+BEGIN_SRC emacs-lisp
(use-package cider
  :hook (clojure-mode . cider-mode)
  :bind ( :map cider-repl-mode-map
         ("<return>" . cider-repl-newline-and-indent)
         ("s-<return>" . cider-repl-return)
         ("C-k" . cider-repl-previous-input)
         ("C-j" . cider-repl-next-input))
  :defer t)
#+END_SRC

** Typescript
*** Pretty ts error
#+BEGIN_SRC emacs-lisp :results silent
(use-package pretty-ts-errors
  :defer t
  :bind (:map meow-normal-state-keymap
              ("\\e" . pretty-ts-errors-show-error-at-point))
  :ensure (pretty-ts-errors :host github :repo "artawower/pretty-ts-errors.el")
  :custom
  (pretty-ts-errors-hide-on-point-move nil))
#+END_SRC
*** Typescript package
#+BEGIN_SRC emacs-lisp
(use-package typescript-ts-mode
  :ensure nil
  :defer t
  :mode
  ("\\.mts\\'" . typescript-ts-mode)
  ("\\.ts\\'" . typescript-ts-mode)
  :hook (typescript-ts-mode . (lambda () (setq-local fill-column 120)))
  :custom
  (lsp-clients-typescript-server-args '("--stdio"))
  (typescript-indent-level 2)
  :config
  (setenv "TSSERVER_LOG_FILE" "/tmp/tsserver.log"))
#+END_SRC

** COMMENT Angular
#+BEGIN_SRC emacs-lisp
(use-package ng2-mode
  :after (typescript-mode lsp-mode)
  :defer t)
#+END_SRC

** Js
*** PKG. NPM Script runner
#+BEGIN_SRC emacs-lisp
(use-package pkg-run
  :ensure (:host github :repo "Artawower/pkg-run")
  :bind (("C-c j r" . pkg-run-script)
         ("C-c j m" . pkg-run-menu)
         ("C-c s r" . pkg-run-script))
  :custom
  (pkg-run-package-manager 'bun)
  :defer t)
#+END_SRC
*** REPL
**** NodeJs repl
#+BEGIN_SRC emacs-lisp
(use-package nodejs-repl
  :ensure t
  :bind
  (("C-c r n" . nodejs-repl)
   :map nodejs-repl-mode-map
   ("C-j" . comint-next-input)
   ("C-k" . comint-previous-input))
  :defer t
  :config
  (add-to-list 'display-buffer-alist '("^\\*nodejs\\*$" . (display-buffer-same-window))))
#+END_SRC

** WEB mode development
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
  :mode
  ("\\.tsx\\'" . web-mode)
  ("\\.jsx\\'" . web-mode)
  ("\\.astro\\'" . web-mode)
  :custom
  (web-mode-enable-auto-quoting nil)
  (web-mode-comment-formats
        '(("java"       . "/*")
          ("javascript" . "//")
          ("typescript" . "//")
          ("vue"        . "//")
          ("php"        . "/*")
          ("pug"        . "//")
          ("css"        . "/*")))
  (web-mode-script-padding 0)
  (web-mode-style-padding 0)
  (web-mode-code-indent-offset 2)
  (web-mode-css-indent-offset 2))
#+END_SRC
** Vue
Requires Emacs 30+
#+BEGIN_SRC emacs-lisp
(use-package vue-ts-mode
    :ensure (:host github :repo "8uff3r/vue-ts-mode")
    :mode ("\\.vue\\'" . vue-ts-mode))
#+END_SRC
** PUG
#+BEGIN_SRC emacs-lisp
(use-package pug-mode :defer t)
#+END_SRC

** HTML
*** Delete pair tag
#+BEGIN_SRC emacs-lisp :results silent
(defun my/delete-pair-tag ()
  "Delete current tag under cursor and its pair"
  (interactive)
  (save-excursion
    (when (re-search-backward "<" nil t)
      (when (looking-at "</")
        (let ((count 1) tag-name)
          (forward-char 2)
          (re-search-forward "\\([a-zA-Z][a-zA-Z0-9-]*\\)")
          (setq tag-name (match-string 1))
          (re-search-backward "<")
          (while (and (> count 0) (re-search-backward (format "</?%s[> ]" tag-name) nil t))
            (setq count (if (looking-at "</") (1+ count) (1- count))))))
      (when (looking-at "<[^/]")
        (let ((tag-open-start (point)) tag-open-end tag-name count)
          (forward-char)
          (re-search-forward "\\([a-zA-Z][a-zA-Z0-9-]*\\)")
          (setq tag-name (match-string 1))
          (re-search-forward ">")
          (setq tag-open-end (point) count 1)
          (while (and (> count 0) (re-search-forward (format "</?%s[> ]" tag-name) nil t))
            (setq count (if (string= (substring (match-string 0) 0 2) "</") (1- count) (1+ count))))
          (when (= count 0)
            (re-search-backward "<")
            (delete-region (point) (progn (re-search-forward ">") (point)))
            (delete-region tag-open-start tag-open-end)))))))
#+END_SRC
*** Emmet. Quick tag expanding
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer t
  :hook
  (scss-mode . emmet-mode)
  (css-mode . emmet-mode)
  (ng2-html-mode . emmet-mode)
  (html-mode . emmet-mode)
  (vue-mode . emmet-mode)
  (vue-ts-mode . emmet-mode)
  :bind (:map emmet-mode-keymap
              ("s-e" . emmet-expand-line)
              ("C-j" . nil)))
#+END_SRC
** JSON
*** JQ, json query tool
#+BEGIN_SRC emacs-lisp
(use-package jq-mode :defer t)
#+END_SRC

** Golang
#+BEGIN_SRC emacs-lisp
(use-package go-playground
  :defer t)
#+END_SRC

** Rust
*** Quick jump to documentation
#+BEGIN_SRC emacs-lisp :results silent
(defun my/rust-std-docs-open ()
  "Get the type under cursor and open the browser with documentation for this type."
  (interactive)
  (let ((symbol (thing-at-point 'symbol t)))
    (if symbol
        (browse-url (format "https://doc.rust-lang.org/std/?search=%s" symbol))
      (browse-url "https://doc.rust-lang.org/std/"))))
#+END_SRC
*** COMMENT Rust language
#+BEGIN_SRC emacs-lisp
(use-package rustic
  :defer t
  :bind (:map rustic-mode-map
              ("C-c C-c s" . lsp-rust-analyzer-status))
  :custom
  (rustic-format-on-save t)
  (rustic-lsp-client 'eglot)
  (rustic-format-display-method 'ignore)
  :config
  (setenv "CARGO_TERM_COLOR" "never"))
#+END_SRC
*** Rust playground
#+BEGIN_SRC emacs-lisp :results silent
(use-package rust-playground :defer 8)
#+END_SRC
*** Cargo
#+BEGIN_SRC emacs-lisp :results silent
(use-package cargo-transient
  :after rust-ts-mode
  :bind (:map rust-ts-mode-map
              ("C-c s r" . cargo-transient)))
#+END_SRC
*** Rust ts mode
#+BEGIN_SRC emacs-lisp :results silent
(use-package rust-ts-mode
  :ensure nil
  :mode "\\.rs\\'"
  :hook (rust-ts-mode . (lambda ()
                          ;; Disable built-in rust-ts-flymake, eglot provides diagnostics
                          (remove-hook 'flymake-diagnostic-functions 'rust-ts-flymake t))))
#+END_SRC
** Flutter
*** Dart
#+BEGIN_SRC emacs-lisp
(use-package dart-mode
  :hook (dart-mode . flutter-test-mode))
#+END_SRC
*** Flutter mode
#+BEGIN_SRC emacs-lisp
(use-package flutter
  :after dart-mode
  :bind
  (("C-c m f s" . flutter-run)
   ("C-c m f R" . flutter-hot-restart)
   ("C-c m f r" . flutter-run-or-hot-reload)
   :map dart-mode-map
   ("C-c C-r" . flutter-run-or-hot-reload))
  :custom
  (flutter-sdk-path (or (getenv "FLUTTER_ROOT") "/Applications/flutter/")))
#+END_SRC

** Docker compose
#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode
  :defer t)
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :defer t
  :bind ("C-c o d" . docker))
#+END_SRC
** Jenkins
#+BEGIN_SRC emacs-lisp
(use-package jenkinsfile-mode
  :defer t)
#+END_SRC
** K8S
#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :defer t
  :commands (kubernetes-overview)
  :bind (("C-c o K" . kubernetes-overview))
  :custom
  (kubernetes-poll-frequency 3600)
  (kubernetes-redraw-frequency 3600))

(use-package k8s-mode
  :defer t)
#+END_SRC

** NGINX
#+BEGIN_SRC emacs-lisp
(use-package nginx-mode
  :defer t)
#+END_SRC

** Jinja
#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode
  :defer t)
#+END_SRC

** Markdown
*** Core package
#+BEGIN_SRC emacs-lisp :results silent
(use-package markdown-mode
  :mode (("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :config
  (setq markdown-fontify-code-blocks-natively nil))
#+END_SRC
*** Realtime preview
#+BEGIN_SRC emacs-lisp
(use-package grip-mode
  :defer t
  :config
  (let ((credential (auth-source-user-and-password "api.github.com")))
    (when credential
      (setq grip-github-user (car credential)
            grip-github-password (cadr credential)))))
#+END_SRC
*** Xwidget preview
#+BEGIN_SRC emacs-lisp
(use-package markdown-xwidget
  :after markdown-mode
  :ensure (markdown-xwidget
             :type git
             :host github
             :repo "cfclrk/markdown-xwidget"
             :files (:defaults "resources"))
  :bind (:map markdown-mode-command-map
              ("x" . markdown-xwidget-preview-mode))
  :custom
  (markdown-xwidget-command "pandoc")
  (markdown-xwidget-github-theme "light")
  (markdown-xwidget-mermaid-theme "default")
  (markdown-xwidget-code-block-theme "default"))
#+END_SRC

** Kdl mode
#+BEGIN_SRC emacs-lisp
(use-package kdl-mode :defer t)
#+END_SRC
** Fish
#+BEGIN_SRC emacs-lisp
(use-package fish-mode :defer t)
#+END_SRC

** Xonsh
#+BEGIN_SRC emacs-lisp :results silent
(use-package xonsh-mode :defer t)
#+END_SRC

** Mermaid
*** Core pakcage
#+BEGIN_SRC emacs-lisp :results silent
(use-package mermaid-ts-mode :defer t)
#+END_SRC
*** Preview
#+BEGIN_SRC emacs-lisp :results silent
(defun my/preview-mermaid ()
  "Render region inside a webit embebed browser."
  (interactive)
  (unless (region-active-p)
    (call-interactively 'mark-whole-buffer))
  (let* ((path (concat (make-temp-file (temporary-file-directory)) ".html"))
         (mermaid-code (buffer-substring-no-properties (region-beginning) (region-end))))
    (save-excursion
      (with-temp-buffer
        (insert "<body>
  <pre class=\"mermaid\">")
        (insert mermaid-code)
        ;; js script copied from mermaid documentation
        (insert "</pre>
  <script type=\"module\">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>
</body>")
        (write-file path)))
    (xwidget-webkit-browse-url (format "file://%s" path))))
#+END_SRC
*** Org babel
#+BEGIN_SRC emacs-lisp :results silent
(use-package ob-mermaid
  :config
  (with-eval-after-load 'org
    (add-to-list 'org-babel-load-languages '(mermaid . t) t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     org-babel-load-languages))
  )
#+END_SRC
** Dotnet
#+BEGIN_SRC emacs-lisp :results silent
(use-package nxml-mode
  :ensure nil
  :mode
  ("\\.csproj\\'" . nxml-mode))
#+END_SRC
** Justfile
#+BEGIN_SRC emacs-lisp :results silent
(use-package just-ts-mode
   :defer t)
#+END_SRC
** ECA. Agnostic code assistant
*** Functions
**** Open last eca view diff
#+BEGIN_SRC emacs-lisp
(defun my/open-last-view-diff ()
  "Open latest view diff from eacs"
  (interactive)
  (let* ((win   (selected-window))
         (pt    (point))
         (start (window-start win)))
    (unwind-protect
        (progn
          (save-restriction
            (widen))
          (goto-char (point-max))
          (unless (re-search-backward "view diff" nil t)
            (user-error "No 'view diff' found in buffer"))
          (goto-char (match-beginning 0))
          (eca-chat--key-pressed-return))
      (when (window-live-p win)
        (set-window-start win start t)
        (set-window-point win pt)))))

#+END_SRC
*** Package
#+BEGIN_SRC emacs-lisp
(defvar flymake-allowed-file-name-masks nil)
(setq flymake-err-line-patterns nil)

(use-package eca
  :defer 10
  :ensure (:type git :host github :repo "editor-code-assistant/eca-emacs" :files (:defaults "*.el"))
  ;; :ensure (:type git :host github :repo "artawower/eca-emacs" :files (:defaults "*.el"))
  :custom
  (eca-chat-diff-tool 'ediff)
  (eca-chat-use-side-window nil)
  (eca-chat-mcp-tool-call-success-symbol
   (propertize "ó°„­" 'face 'font-lock-string-face 'display '(height 1.3)))
  (eca-chat-mcp-tool-call-loading-symbol
   (propertize "" 'face 'default 'display '(height 1.3)))
  (eca-chat-mcp-tool-call-error-symbol
   (propertize "" 'face 'font-lock-builtin-face 'display '(height 1.3)))
  :bind (("C-c e e" . eca)
         ("C-c e m" . eca-transient-menu)
         ("s-g" . eca-transient-menu)
         :map eca-chat-mode-map
         ("<tab>" . eca-chat-toggle-expandable-block)
         ("C-c C-v" . my/open-last-view-diff)
         ("s-<return>" . eca-chat--key-pressed-return)
         ("<return>" . eca-chat--key-pressed-newline)
         ("RET" . eca-chat--key-pressed-newline)
         ("C-k" . eca-chat--key-pressed-previous-prompt-history)
         ("C-j" . eca-chat--key-pressed-next-prompt-history)
         ("C-S-j" . eca-chat-go-to-next-expandable-block)
         ("C-S-k" . eca-chat-go-to-prev-expandable-block))
  :config

  (add-to-list
   'display-buffer-alist
   '("<eca-chat.*"
     (my/display-buffer-right-smart)
     (window-width . 0.4))))
;; (my/display-buffer-right-smart))))
#+END_SRC

** Copilot
deps
#+BEGIN_SRC emacs-lisp :tangle no
(use-package track-changes
  :preface (unload-feature 'track-changes t)
  :ensure (track-changes
           :host github
           :repo "emacs-mirror/emacs"
           :branch "master"
           :files ("lisp/emacs-lisp/track-changes.el")
           :depth 1
           :inherit nil))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package copilot
  ;; :ensure (copilot :host github :repo "copilot-emacs/copilot.el" :files ("*.el") :ref "c42c18e346e1ff8399eb30d40527e593f614e4d3")
  ;; :hook
  ;; (prog-mode . copilot-mode)
  ;; (text-mode . copilot-mode)
  :bind
  (("s-]" . copilot-next-completion)
   ("s-[" . copilot-previous-completion)
   ("s-l" . copilot-accept-completion)
   ("s-k" . copilot-accept-completion)
   ("s-j" . copilot-complete)
   ("s-;" . copilot-accept-completion-by-word)
   ("s-/" . copilot-accept-completion-by-line))
  :custom
  (copilot-idle-delay 0.3)
  (copilot--previous-point nil)
  (copilot--previous-window-width nil)
  :config
  (add-hook 'meow-insert-enter-hook (lambda ()
                                      (setq blamer--block-render-p t)
                                      (blamer--clear-overlay)))
  (add-hook 'meow-insert-exit-hook (lambda ()
                                     (setq blamer--block-render-p nil)
                                     (copilot-clear-overlay)))

  (defun my/copilot-show-overlay-depends-mode (COMPLETION UUID START END)
    ;; If meow normal mode prevent copilot from showing overlay
    (unless (bound-and-true-p meow-normal-mode)
      (copilot--display-overlay-completion COMPLETION UUID START END)))
  (advice-add 'copilot-show-overlay :override #'my/copilot-show-overlay-depends-mode))
#+END_SRC


* Org mode
** Org GPG encryption
#+BEGIN_SRC emacs-lisp
(setq epa-pinentry-mode 'loopback)
(use-package org-crypt
  :defer t
  :ensure nil
  :custom
  (org-crypt-key nil)
  (org-tags-exclude-from-inheritance (quote ("crypt")))
  :config
  (org-crypt-use-before-save-magic))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package epa
  :defer t
  :ensure nil
  :custom
  (epg-pinentry-mode 'loopback)
  (epa-file-encrypt-to my/user-email)
  :config
  (epa-file-enable))
#+END_SRC

** Org babels
*** HTTP requests
Dependency

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-restclient
  :defer t)
#+END_SRC

*** Dart
#+BEGIN_SRC emacs-lisp
(use-package ob-dart
  :defer t
  :config
  (add-to-list 'org-babel-load-languages  '(dart . t)))
#+END_SRC
*** Typescript
#+BEGIN_SRC emacs-lisp
(use-package ob-typescript
  :defer t)
#+END_SRC
*** Golang
#+BEGIN_SRC emacs-lisp
(use-package ob-go :defer t)
#+END_SRC
*** Rust
#+BEGIN_SRC emacs-lisp
(use-package ob-rust :defer t)
#+END_SRC

** Faces
#+BEGIN_SRC emacs-lisp
(defun my/setup-org-mode-faces ()
  "Setup faces for org mode"
  ;; (custom-set-faces
  ;;  '(org-document-title ((t (:inherit outline-1 :height 2.5)))))
)
#+END_SRC

** Copy src block
#+BEGIN_SRC emacs-lisp
(defun my/copy-src-block ()
  "Copy org src block contents (without #+begin/#+end) to clipboard. Handles Emacs 30+ deferred values."
  (interactive)
  (let ((src-block (org-element-at-point)))
    (when (eq (car src-block) 'src-block)
      (let ((val (org-element-property :value src-block)))
        (kill-new val)
        (message "Source block copied. %s" val)))))
#+END_SRC
** Tangle block under cursor
#+BEGIN_SRC emacs-lisp
(defun my/org-babel-tangle-current-block ()
  "Tangle only the org-babel source block at point, if it has a :tangle header.
Automatically creates parent directories if needed."
  (interactive)
  (let* ((info (org-babel-get-src-block-info 'light))
         (lang (nth 0 info))
         (params (nth 2 info))
         (tangle (cdr (assoc :tangle params)))
         (body (nth 1 info)))
    (unless (and info tangle (not (string= tangle "no")))
      (user-error "No :tangle file specified for this block"))
    (let* ((file (expand-file-name tangle (file-name-directory (or (buffer-file-name) default-directory))))
           (dir (file-name-directory file))
           (tangled-code (org-babel-expand-body:generic body params)))
      (unless (file-exists-p dir)
        (make-directory dir t))
      (with-temp-file file
        (insert tangled-code))
      (message "Tangled block to %s" file))))
#+END_SRC

** Init org ligatures
#+BEGIN_SRC emacs-lisp
(defun my/init-org-ligatures ()
  "Initialize org mode ligatures."
  (push '("[ ]" .  "â˜") prettify-symbols-alist)
  (push '("[X]" . "â˜‘" ) prettify-symbols-alist)
  (push '("[-]" . "â" ) prettify-symbols-alist)
  (push '("#+BEGIN_SRC" . "â†¦" ) prettify-symbols-alist)
  (push '("#+END_SRC" . "â‡¤" ) prettify-symbols-alist)
  (push '("#+BEGIN_EXAMPLE" . "â†¦" ) prettify-symbols-alist)
  (push '("#+END_EXAMPLE" . "â‡¤" ) prettify-symbols-alist)
  (push '("#+BEGIN_QUOTE" . "â†¦" ) prettify-symbols-alist)
  (push '("#+END_QUOTE" . "â‡¤" ) prettify-symbols-alist)
  (push '("#+begin_quote" . "â†¦" ) prettify-symbols-alist)
  (push '("#+end_quote" . "â‡¤" ) prettify-symbols-alist)
  (push '("#+begin_example" . "â†¦" ) prettify-symbols-alist)
  (push '("#+end_example" . "â‡¤" ) prettify-symbols-alist)
  (push '("#+begin_src" . "â†¦" ) prettify-symbols-alist)
  (push '("#+end_src" . "â‡¤" ) prettify-symbols-alist)

  (push '("#+TITLE:" . "ï„©") prettify-symbols-alist)
  (push '("#+DESCRIPTION:" . "ïƒ¶") prettify-symbols-alist)
  (push '("#+LANG:" . "î¢”") prettify-symbols-alist)
  (push '("#+ID:" . "ïŠ’") prettify-symbols-alist)
  (push '("#+FILETAGS:" . "ï€«") prettify-symbols-alist)
  (push '("#+STARTUP:" . "ï€º") prettify-symbols-alist)
  (push '("#+ACTIVE:" . "ï…Š") prettify-symbols-alist)
  (push '("#+START_SPOILER" . "ï£") prettify-symbols-alist)
  (push '("#+CLOSE_SPOILER" . "ï£") prettify-symbols-alist)
  (push '("#+BEGIN_HIDDEN" . "ï…") prettify-symbols-alist)
  (push '("#+END_HIDDEN" . "ï…‘") prettify-symbols-alist)
  (prettify-symbols-mode))
#+END_SRC
** Org mode, tab indent
#+BEGIN_SRC emacs-lisp :results silent
(defun my/org-indent-dwim ()
  (interactive)
  (if (org-in-src-block-p)
      (org-indent-line)
    (org-cycle)))

(define-key org-mode-map (kbd "TAB") 'my/org-indent-dwim)
(define-key org-mode-map
  (kbd "<tab>") #'my/org-indent-dwim)

#+END_SRC
** Org core package
#+BEGIN_SRC emacs-lisp
(use-package org
  :mode (("\\.org$" . org-mode))
  :after meow
  :ensure nil
  :hook
  (org-mode . org-indent-mode)
  (org-mode . (lambda () (corfu-mode -1)))
  (org-mode . (lambda () (setq truncate-lines nil)))
  (org-mode . my/init-org-ligatures)
  :bind
  (:map org-mode-map
        ("M-t" . org-todo)
        ("C-c l s" . org-store-link)
        ("M-l l" . org-insert-link)
        ("C-c l l" . org-insert-link)
        ("C-c d t" . org-time-stamp-inactive)
        ("M-l t" . org-toggle-link-display)
        ("C-c l d" . org-toggle-link-display)
        ("C-c t b" . my/org-babel-tangle-current-block)
        ("C-c C-b" . nil)
        ("C-c b ]" . org-babel-next-src-block)
        ("C-c b [" . org-babel-previous-src-block)
        ("C-c d t" . org-time-stamp-inactive)
        ("C-c s t" . org-set-tags-command)
        ("C-c x" . org-toggle-checkbox)
        ("C-c h ]" . org-next-visible-heading)
        ("C-c h [" . org-previous-visible-heading)
        ("C-h ]" . org-next-visible-heading)
        ("C-h [" . org-previous-visible-heading)
        ("C-h n" . org-babel-next-src-block)
        ("C-h p" . org-babel-previous-src-block)
        :map meow-normal-state-keymap
        ("\\o" . org-mode)
        ("\\a" . org-agenda)
        :map org-read-date-minibuffer-local-map
        ("C-s" . org-goto-calendar)
        :map calendar-mode-map
        ("<return>" . org-calendar-select))
  :custom
  (org-directory my/org-roam-dir)
  (org-log-done 'time)
  (org-babel-python-command "python3")
  (org-confirm-babel-evaluate nil)
  (org-clock-report-include-clocking-task t)
  (org-src-preserve-indentation t)
  (org-latex-create-formula-image-program 'dvisvgm)
  (org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  ;; https://www.reddit.com/r/orgmode/comments/jwf7ya/python_org_code_blocks_and_indentation/
  (org-adapt-indentation nil)
  (org-imenu-depth 8)
  (org-src-window-setup 'current-window)
  (org-todo-keywords
   '((sequence
      "TODO(t)"     ; A task that needs doing & is ready to do
      "PROJ(p)"     ; A project, which usually contains other tasks
      "IDEA(i)"     ; Idea
      "PROGRESS(s)" ; A task that is in progress
      "WAIT(w)"     ; Something external is holding up this task
      "TEST(c)"     ; In TEST statement
      "BLOCK(b)"    ; task blocked
      "REJECTED(x)" ; somebody rejected idea :(
      "FEEDBACK(f)" ; Feedback required
      "REVIEW(r)"   ; Somebody reviewed your feature
      "HOLD(h)"     ; This task is paused/on hold because of me
      "|"
      "DONE(d)"     ; Task successfully completed
      "KILL(k)")    ; Task was cancelled, aborted or is no longer applicable
     (sequence
      "[ ](T)"      ; A task that needs doing
      "[-](S)"      ; Task is in progress
      "[?](W)"      ; Task is being held up or paused
      "|"
      "[X](D)"))    ; Task was completed
   org-todo-keyword-faces
   '(("PROGRESS"   . org-warning)
     ("DONE"       . org-done)
     ("IDEA"       . org-todo)
     ("WAIT"       . org-todo)
     ("TEST"       . org-warning)
     ("FEEDBACK"   . org-todo)
     ("REVIEW"     . org-todo)
     ("HOLD"       . org-todo)
     ("PROJ"       . org-level-1)
     ("BLOCK"      . org-done)
     ("REJECTED"   . org-done)
     ("KILL"       . org-done)))

  (org-highest-priority ?A)
  (org-default-priority ?C)
  (org-lowest-priority ?E)
  (org-hide-emphasis-markers t)
  (org-use-property-inheritance t)
  :config
  (require 'ob-clojure)
  (add-to-list 'org-src-lang-modes '("typescript" . typescript-ts))
  (add-to-list 'org-src-lang-modes '("ts" . typescript-ts))
  (add-to-list 'org-src-lang-modes '("python" . python-ts))
  (add-to-list 'org-src-lang-modes '("rust" . rust-ts))
  (setq org-capture-templates
        `(("t" "Task â†’ Inbox" entry
           (file ,(expand-file-name "inbox.org" my/agenda-dir))
           "* TODO %? :inbox:\nSCHEDULED: %^{When}t\n%U\n"
           :empty-lines 1 :prepend t)
          ("w" "Work â†’ Next actions" entry
           (file+headline ,(expand-file-name "work.org" my/agenda-dir) "Next actions")
           "* TODO %? :work:\n%U\n"
           :empty-lines 1 :prepend t)
          ("l" "Live â†’ Next actions" entry
           (file+headline ,(expand-file-name "live.org" my/agenda-dir) "Next actions")
           "* TODO %? :live:\n%U\n"
           :empty-lines 1 :prepend t)
          ("e" "Task â†’ environment" entry
           (file ,(expand-file-name "environment.org" my/agenda-dir) "Next actions")
           "* TODO %? :env:\nSCHEDULED: %^{When}t\n%U\n"
           :empty-lines 1 :prepend t)))
  (my/setup-org-mode-faces)
  (add-hook 'org-mode-hook
            (lambda () (imenu-add-to-menubar "Imenu")))

  (add-to-list 'org-tag-faces '("@.*" . (:foreground "red")))


  (setenv "NODE_PATH" "/opt/homebrew/lib/node_modules")

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sql . t)
     (typescript . t)
     (js . t)
     (python . t)
     (rust . t)
     (restclient . t)
     (shell . t)))

  (defun org-babel-execute:typescript (body params)
    (let ((org-babel-js-cmd "npx ts-node < "))
      (org-babel-execute:js body params))))

#+END_SRC

** Org agenda core package
#+BEGIN_SRC emacs-lisp :results silent
(use-package org-agenda
  :ensure nil
  :defer t
  :bind (("C-c a o" . my/open-agenda-file)
         ("C-c a a" . org-agenda-list))
  :custom
  (org-log-done 'note)
  (org-agenda-span 'day)
  (org-agenda-show-log t)
  (org-agenda-start-with-log-mode t)
  (org-agenda-log-mode-items '(closed state))
  :config
  (add-to-list 'display-buffer-alist
             '("\\*Org Agenda\\*" my/display-buffer-full-size))

  (defun my/save-org-file-buffers (&rest _args)
    (save-window-excursion
      (save-some-buffers t (lambda ()
                             (and (derived-mode-p 'org-mode)
                                  (buffer-file-name)))))
    (when (featurep 'org-id) (org-id-locations-save)))

  (advice-add 'org-agenda-todo :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-priority :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-set-tags :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-deadline :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-schedule :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-date-prompt :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-clock-in :after 'my/save-org-file-buffers)
  (advice-add 'org-agenda-clock-out :after 'my/save-org-file-buffers)
  (advice-add 'org-store-log-note :after 'my/save-org-file-buffers)

  (my/patch-org-agenda-capture-template)
  (setq org-agenda-files (list my/agenda-dir)))

#+END_SRC

** Fix agenda templates
#+BEGIN_SRC emacs-lisp :results silent
(defun my/patch-org-agenda-capture-template ()
  (advice-add 'org-capture-place-template :around
              (lambda (orig &rest args)
                (let ((inhibit-modification-hooks t))
                  (apply orig args)))))
#+END_SRC

** Visit org agenda files
#+BEGIN_SRC emacs-lisp :results silent
(defun my/open-agenda-file ()
  "Open folder with emacs config"
  (interactive)
  (let ((default-directory my/agenda-dir))
    (call-interactively 'find-file)))
#+END_SRC

** Org superagenda
#+BEGIN_SRC emacs-lisp :results silent
(use-package org-super-agenda
  :after org
  :hook (org-agenda-mode . org-super-agenda-mode)
  :config
  (setq org-super-agenda-header-map (make-sparse-keymap))
  (setq org-super-agenda-groups
        '((:name "ï€Œ  Done today" :log t :log "closed" :todo "DONE" :order 6 :face 'shadow)
          (:name "ï¡  Next work" :and (:category "work" :tag "next" :not (:todo "DONE")) :order 1)
          (:name "î»·  Next pet" :and (:category ("pet" "env" "ticktick" "inbox" "gearpick") :tag ("next" "env" "orgnote" "gearpick") :not (:todo "DONE")) :order 2)
          (:name "î¼¹  Live" :and (:tag "live" :not (:todo "DONE") :not (:category "habit")) :order 3)
          (:name "ï†ƒ  Habit" :and (:habit t :not (:todo "DONE")) :order 4)
          (:name "ó±—– Inbox" :category "Inbox" :and (:tag "inbox" :not (:todo "DONE")) :order 5)
          (:name "ï…«  Other" :anything t :order 7)
          (:discard (:tag "someday")))))
#+END_SRC

** Org agenda habits
#+BEGIN_SRC emacs-lisp :results silent
(use-package org-habit
  :ensure nil
  :defer t
  :custom
  (org-habit-graph-column 50)
  (org-habit-preceding-days 14)
  (org-habit-following-days 3)
  (org-habit-show-all-today t)
  :config
  (add-to-list 'org-modules 'org-habit))
#+END_SRC
** Habit stats
#+BEGIN_SRC emacs-lisp :results silent
(use-package org-habit-stats
  :defer t)
#+END_SRC
** Ticktick integration
#+BEGIN_SRC emacs-lisp :results silent
(use-package ticktick
  :ensure (:host github :repo "Artawower/ticktick.el" :branch "async")
  :commands (ticktick-sync)
  :defer t
  :custom
  (ticktick-autosync t)
  (ticktick-sync-file (concat my/org-roam-dir "/agenda/ticktick.org"))
  (ticktick-dir (concat my/org-roam-dir "/agenda/")))
#+END_SRC
** Org menu
#+BEGIN_SRC emacs-lisp
(use-package org-menu
  :defer t
  :ensure (:host github :repo "sheijk/org-menu")
  :bind (("C-c o a" . org-menu)))
#+END_SRC


** Prettify org priority
#+BEGIN_SRC emacs-lisp
(use-package org-fancy-priorities
  :hook (org-mode . org-fancy-priorities-mode)
  :custom
  (org-fancy-priorities-list '((?A . "ó°ˆ¸")
                               (?B . "î©¬")
                               (?C . "ó±ˆ¸")
                               (?D . "ïˆº")
                               (?E . "ï£")
                               (?1 . "ó°ˆ¸")
                               (?2 . "î…")
                               (?3 . "â®®")
                               (?4 . "ó°…¶")
                               (?I . "ï„©"))))
#+END_SRC

** Pretty org stars
#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :hook (org-mode . org-superstar-mode))
#+END_SRC

** Custom org creation function
#+BEGIN_SRC emacs-lisp :results silent
(defun my/org-node-create-in-current-dir (&rest _)
  "Create org-node file in current directory, using org-node-proposed-*."
  (unless (and (boundp 'org-node-proposed-title) org-node-proposed-title
               (boundp 'org-node-proposed-id)    org-node-proposed-id)
    (user-error "org-node-proposed-title/id did not set"))

  (let* ((title org-node-proposed-title)
         (id    org-node-proposed-id)
         (dir   (file-name-directory (or (buffer-file-name) default-directory)))
         (safe-title (replace-regexp-in-string "[/\\:*?\"<>|]" "" title))
         (file  (expand-file-name (concat safe-title ".org") dir)))
    (unless (file-exists-p file)
      (with-temp-buffer
        (insert ":PROPERTIES:\n:ID: " id "\n:END:\n\n")
        (insert "#+title: " title "\n")
        (insert "#+filetags:\n\n")
        (write-file file)))
    file))

#+END_SRC
** Org node. Org roam alternative
#+BEGIN_SRC emacs-lisp
(use-package org-mem
  :config
  (setq org-mem-do-sync-with-org-id t)
  (setq org-mem-watch-dirs
        (list my/org-roam-dir))
  (org-mem-updater-mode))

(use-package org-node
  :after org-mem
  :bind
  (("C-c n r f" . org-node-find)
   ("C-c n r i" . org-node-insert-link))
  :custom
  (org-node-alter-candidates t)
  (org-node-creation-fn #'org-node-new-via-roam-capture)
  (org-node-file-slug-fn #'org-node-slugify-like-roam-default)
  (org-node-file-timestamp-format "%Y%m%d%H%M%S-")
  :config
  (setq org-node-creation-fn #'my/org-node-create-in-current-dir)
  (org-node-cache-mode)
  (org-node-roam-accelerator-mode)
  (setq org-node-affixation-fn
        (defun my/org-node-prefix-with-tag (node title)
          "Let NODE's tags prefix TITLE."
          (list title
                (when-let ((tags (org-node-get-tags node)))
                  (propertize (concat "(" (string-join tags ", ") ") ")
                              'face `(:foreground ,my/org-tag-color :weight bold :slant italic)))
                nil))))
#+END_SRC


** Image inserting to org documents
#+BEGIN_SRC emacs-lisp
(use-package org-yt
  :defer t
  :ensure (:host github :repo "TobiasZawada/org-yt")
  :config
  (defun org-image-link (protocol link _description)
    "Interpret LINK as base64-encoded image data."
    (cl-assert (string-match "\\`img" protocol) nil
               "Expected protocol type starting with img")
    (let ((buf (url-retrieve-synchronously (concat (substring protocol 3) ":" link))))
      (cl-assert buf nil
                 "Download of image \"%s\" failed." link)
      (with-current-buffer buf
        (goto-char (point-min))
        (re-search-forward "\r?\n\r?\n")
        (buffer-substring-no-properties (point) (point-max)))))

  (org-link-set-parameters
   "imghttp"
   :image-data-fun #'org-image-link)

  (org-link-set-parameters
   "imghttps"
   :image-data-fun #'org-image-link))
#+END_SRC

** Orgnote. Roam publisher for second brain project
My own package for publish roam files
#+BEGIN_SRC emacs-lisp
(use-package orgnote
  :ensure (:host github :repo "Artawower/orgnote.el" :branch "dev")
  :bind
  (("C-c n p" . orgnote-publish-file)
   ("C-c n F" . orgnote-force-sync)
   ("C-c n S" . orgnote-sync)
   :map org-mode-map
   ("C-c n P" . orgnote-publish-all)
   ("C-c n L" . orgnote-load))
  :custom
  (orgnote-debug-p t)
  (orgnote-execution-script "bun /Users/darkawower/projects/pet/orgnote/orgnote-cli/dist/index.js"))

#+END_SRC


** Table of contents
#+BEGIN_SRC emacs-lisp
(use-package org-make-toc
  :bind (:map org-mode-map
              ("C-c o g" . org-make-toc)))
#+END_SRC

** Org exporters
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :defer t
  :ensure (ox-gfm :type git :host github :repo "larstvei/ox-gfm"))
#+END_SRC

** Better enter handling
#+BEGIN_SRC emacs-lisp
(use-package org-smart-enter
  :ensure (org-smart-enter :type git :host github :repo "artawower/org-smart-enter.el")
  :hook (org-mode . org-smart-enter-mode)
  :config
  (org-smart-enter-setup))
#+END_SRC

** Org raindrop
#+BEGIN_SRC emacs-lisp
(use-package raindrop
  :bind (("C-c r s" . raindrop-search))
  :ensure (raindrop :host github :repo "artawower/raindrop.el"))
#+END_SRC

Raindrop search
#+BEGIN_SRC emacs-lisp
(use-package raindrop-search
  :ensure nil
  :after raindrop)
#+END_SRC
Ob raindrop (dynamic block)
#+BEGIN_SRC emacs-lisp
(use-package ob-raindrop
  :after org
  :commands (org-babel-execute:raindrop)
  :ensure nil
  :config
  (with-eval-after-load 'org
    (add-to-list 'org-babel-load-languages '(raindrop . t) t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     org-babel-load-languages)))
#+END_SRC

** Org excalidraw
#+BEGIN_SRC emacs-lisp :results silent
(use-package org-excalidraw
  :defer t
  :ensure (:type git :host github :repo "wdavew/org-excalidraw")
  :custom
  (org-excalidraw-directory my/org-roam-charts-dir)
  :config
  (push '("\\.excalidraw.svg\\'" . "echo '%s' | sed 's/.svg//' | xargs open") org-file-apps)
  (advice-add #'org-display-inline-images :after #'org-display-user-inline-images))
#+END_SRC

* Translation
** Google translate
#+BEGIN_SRC emacs-lisp
(use-package google-translate
  :defer 10
  :bind (:map google-translate-minibuffer-keymap
              ("C-'" . google-translate-next-translation-direction)
              :map meow-normal-state-keymap
              ("\\ t" . google-translate-smooth-translate))
  :config
  (require 'google-translate-smooth-ui)
  (setq google-translate-backend-method 'curl)
  (setq google-translate-pop-up-buffer-set-focus t)
  (setq google-translate-translation-directions-alist
   '(("en" . "ru") ("ru" . "en") ))

  (defun google-translate--search-tkk () "Search TKK." (list 430675 2721866130)))
#+END_SRC

** Jinx. Spellchecker.
#+BEGIN_SRC emacs-lisp
(use-package jinx
  :hook (emacs-startup . global-jinx-mode)
  :custom
  (jinx-languages "en_US ru_RU")
  (jinx-camel-modes '(prog-mode org-mode))
  :bind (("C-c s c" . jinx-correct)
         ("C-c s l" . jinx-languages)
         ("C-c s ]" . jinx-next)
         ("C-c s [" . jinx-previous))
  :config
  (add-to-list 'jinx-camel-modes 'html-ts-mode)
  (add-to-list 'jinx-camel-modes 'html-mode)
  (add-to-list 'jinx-camel-modes 'typescript-ts-mode)
  (setq jinx-enchant-path (executable-find "enchant-2"))  ;; Add function and variable names to jinx faces in prog-mode
  (cl-callf cl-union
      (alist-get 'prog-mode jinx-include-faces)
    '(font-lock-function-name-face
      font-lock-variable-name-face)
    :test #'eq))
 #+END_SRC

* Emacs for everything
** Tramp
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :ensure nil
  :custom
  (remote-file-name-inhibit-cache nil)
  (tramp-verbose 6)
  (tramp-use-ssh-controlmaster-options nil)
  (tramp-default-method "ssh")
  (tramp-completion-reread-directory-timeout nil)
  (vc-ignore-dir-regexp
   (format "\\(%s\\)\\|\\(%s\\)"
           vc-ignore-dir-regexp
           tramp-file-name-regexp))
  :config
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)

  (connection-local-set-profile-variables
   'tramp-connection-local-default-profile
   '((tramp-direct-async-process . t)))

  (connection-local-set-profiles
   '(:application tramp)
   'tramp-connection-local-default-profile))
#+END_SRC
** Pdf tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :defer t
  :config
  (pdf-tools-install))
#+END_SRC

** Notes :refactor:
*** Settings
Display buffer of quick note always at bottom
#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist '("^\\*scratch\\*$" (display-buffer-below-selected) (window-height . 0.4)))
(add-to-list 'display-buffer-alist '("^\\*quicknote\\*$"
                                     (display-buffer-in-side-window)
                                     (inhibit-same-window . t)
                                     (side . bottom)
                                     (window-width . full)
                                     (window-height . 0.3)))
#+END_SRC

*** Switch to scratch buffer
#+BEGIN_SRC emacs-lisp
(defun my/switch-to-scratch ()
  "Switch to scratch buffer"
  (interactive)
  (let* ((buffer-name "*quicknote*")
         (buffer (get-buffer buffer-name)))

    (unless buffer
      (persistent-scratch-setup-default)
      (setq buffer (get-buffer-create buffer-name))
      (persistent-scratch-restore))

    (message "current buffer: %s" buffer)
    (with-current-buffer buffer
      (pop-to-buffer buffer)
      (org-mode)
      (meow-insert))))
#+END_SRC

*** Persistent scratch
Init file for storing persistent scratches
#+BEGIN_SRC emacs-lisp
(defun create-persistent-scratch-file-if-not-exist ()
  "Create the persistent-scratch file if it does not already exist."
  (let ((scratch-file (expand-file-name "var/persistent-scratch.el" user-emacs-directory)))
    (unless (file-exists-p scratch-file)
      (make-directory (file-name-directory scratch-file) t)
      (with-temp-file scratch-file
        (insert ";; Persistent scratch file\n")))))

;; Run the function during startup
(create-persistent-scratch-file-if-not-exist)
#+END_SRC

Override function for autosaving
#+BEGIN_SRC emacs-lisp
(defun my/persistent-scratch-savable-p ()
  "Return non-nil if the current buffer is savable."
  (when-let* ((current-buffer-scratch-p (string= (buffer-name) "*quicknote*"))
              (scratch-buffer (get-buffer "*quicknote*"))
              (scratch-buffer-content (with-current-buffer scratch-buffer
                                        (buffer-string)))
              (scratch-buffer-content-not-empty (not (equal scratch-buffer-content ""))))
    t))

(defun my/save-scratch-buffer-p ()
  "Return non-nil if the current buffer is the scratch buffer."
  (my/persistent-scratch-savable-p))

(setq persistent-scratch-scratch-buffer-p-function #'my/save-scratch-buffer-p)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/preserve-persistent-scratch ()
  "Preserve the persistent scratch buffer. Make backup."
  (interactive)
  (persistent-scratch-save)
  (persistent-scratch-new-backup))
#+END_SRC

#+NAME: persistent-scratch-save
#+BEGIN_SRC emacs-lisp :tangle no
(defun persistent-scratch-save (&optional file)
  "Save the current state of scratch buffers.
When FILE is non-nil, the state is saved to FILE; when nil or when called
interactively, the state is saved to `persistent-scratch-save-file'.
What state exactly is saved is determined by `persistent-scratch-what-to-save'.

When FILE is nil and `persistent-scratch-backup-directory' is non-nil, a copy of
`persistent-scratch-save-file' is stored in that directory, with a name
representing the time of the last `persistent-scratch-new-backup' call."
  (interactive)
  (let* ((actual-file (or file persistent-scratch-save-file))
         (tmp-file (concat actual-file ".new"))
         (saved-state (persistent-scratch--save-buffers-state)))
    (when (car saved-state)
      (let ((old-umask (default-file-modes)))
        (set-default-file-modes #o600)
        (unwind-protect
            (let ((coding-system-for-write 'utf-8-unix))
              (write-region (cdr saved-state) nil tmp-file nil 0))
          (set-default-file-modes old-umask)))
      (run-hook-with-args 'persistent-scratch-before-save-commit-functions tmp-file)
      (rename-file tmp-file actual-file t)
      (dolist (buffer (car saved-state))
        (with-current-buffer buffer
          (set-buffer-modified-p nil)))
      (when (called-interactively-p 'interactive)
        (message "Wrote persistent-scratch file %s" actual-file)))
    (unless file
      (persistent-scratch--update-backup)
      (persistent-scratch--cleanup-backups))))
#+END_SRC

Override autosave function. What is the sense save buffer whic doesn't exist???

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package persistent-scratch
  :demand t
  :bind (("C-c n n" . my/switch-to-scratch))
  :config
  <<persistent-scratch-save>>
  (setq persistent-scratch-backup-directory "~/apps/pure-emacs/backups")
  (persistent-scratch-autosave-mode)
  (setq persistent-scratch-autosave-interval 5))
#+END_SRC

** mu4e mail client
*** Mu4e core package
#+BEGIN_SRC emacs-lisp :results silent
(use-package mu4e
  :load-path "/nix/store/x3miwzs9b838pkl7bka36x70gg3fws2s-emacs-mu4e-1.12.13/share/emacs/site-lisp/elpa/mu4e-1.12.13"
  :defer t
  :bind (("C-c u" . mu4e-transient-menu)
         :map mu4e-main-mode-map
         ("J" . mu4e-search-maildir))
  :config
  (require 'mu4e-transient)
  (setenv "XDG_CACHE_HOME" (expand-file-name "~/.cache"))

  (setq mu4e-maildir "~/Mail"
        mu4e-get-mail-command "mbsync -a"
        mu4e-update-interval 120
        mu4e-index-update-in-background t)

  (setq mu4e-use-fancy-chars t
        mu4e-headers-show-threads t
        mu4e-headers-skip-duplicates t
        mu4e-view-show-images t
        mu4e-view-show-addresses t)

  (setq mu4e-view-prefer-html t)

  (setq mu4e-headers-fields
        '((:from-or-to . 30)
          (:subject . nil)))

  (setq mu4e-marks
        '((delete . (char ?D))
          (trash  . (char ?T))
          (refile . (char ?r))
          (flag   . (char ?f))
          (move   . (char ?m))
          (read   . (char ?R))
          (unread . (char ?U)))))

#+END_SRC

*** Easy setup
#+BEGIN_SRC emacs-lisp :results silent
(use-package mu4easy
  :ensure t
  :config (mu4easy-mode)
  :custom
  (mu4easy-contexts '((mu4easy-context
                       :c-name  "Personal"
                       :maildir "Gmail"
                       :mail    "artawower33@gmail.com"
                       :smtp    "smtp.gmail.com"
                       :sent-action delete)
                      (mu4easy-context
                       :c-name  "Orgnote"
                       :maildir "GmailOrgnote"
                       :mail    "app.orgnote@gmail.com"
                       :smtp    "smtp.gmail.com"
                       :sent-action delete))))
#+END_SRC
* Husky
#+BEGIN_SRC emacs-lisp
(use-package husky
  :defer t
  :ensure (:type git :host github :repo "artawower/husky" :files ("lisp/*.el"))
  :bind (("C-c t t" . husky-edit-insert-todo-by-current-git-branch)
         ("C-c t i" . husky-edit-insert-todo-by-current-git-branch)
         ("C-c t d" . husky-edit-insert-debug-by-current-git-branch)
         ("C-c t n" . husky-edit-insert-note-by-current-git-branch)
         ("C-c o l" . husky-buffers-open-messages)
         ("C-c o M" . husky-buffers-open-clear-messages)
         ("C-c f D" . husky-buffers-delete-this-file)
         ("s-<backspace>" . husky-edit-kill-word-backward)
         ("M-n" . husky-lsp-repeat-consult-search-forward)
         ("M-p" . husky-lsp-repeat-consult-search-backward)
         ("C-c b k i" . husky-buffers-kill-invisible-buffers)
         ("C-c S-SPC" . husky-buffers-side-project-find-file)
         ("C-c b B" . husky-buffers-side-consult-projectile-switch-to-buffer)
         ("C-c >" . husky-buffers-side-find-file)
         :map magit-merge-preview-mode-map
         ("M-n" . husky-lsp-repeat-consult-search-forward)
         ("M-p" . husky-lsp-repeat-consult-search-backward)
         :map meow-normal-state-keymap
         ("gd" . husky-lsp-find-definition)
         ("%" . husky-navigation-bounce-paren)
         ("g F" . husky-lsp-avy-go-to-definition)
         ("g f" . husky-lsp-avy-go-to-definition)
         ("g D" . husky-buffers-side-husky-actions-find-definition)
         ("z r" . husky-fold-open)
         ("z R" . husky-fold-open-all)
         ("s-y" . husky-lsp-copy-to-register-1)
         ("s-p" . husky-lsp-paste-from-register-1)
         ("z A" . husky-fold-toggle-all)
         ("z a" . husky-fold-toggle)
         ("z j" . husky-fold-next)
         ("z M" . husky-fold-close-all)
         ("z k" . husky-fold-previous)
         ("\\ m" . husky-window-manager-toggle-maximize-buffer)
         :map meow-motion-state-keymap
         ("\\ m" . husky-window-manager-toggle-maximize-buffer)
         :map magit-status-mode-map
         ("M-n" . husky-lsp-repeat-consult-search-forward)
         ("M-p" . husky-lsp-repeat-consult-search-backward)))
#+END_SRC

* Overrides
#+BEGIN_SRC emacs-lisp :results silent
;; (setenv "SHELL" "/run/current-system/sw/bin/zsh")
(setenv "SHELL" "/Users/darkawower/.nix-profile/bin/dash")
(setenv "SHELL" (executable-find "dash"))
#+END_SRC

* End config
#+BEGIN_SRC emacs-lisp
(elpaca-wait)
#+END_SRC
